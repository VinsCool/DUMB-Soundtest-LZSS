mads 2.1.3
Source: lzssp.asm
     1 				;* When used in a project, the LZSS driver must be assembled from this file!
     2 				;* Include everything needed below, and edit accordingly.
     3
     4 				;-----------------
     5
     6 				;//---------------------------------------------------------------------------------------------
     7
     8 				;* Build flags, they are not the requirement, and could be changed if necessary 
     9
    10 					OPT R- F-
    11 					icl "atari.def"			; Missing or conflicting labels cause build errors, be extra careful! 
Source: atari.def
     1 				;* some memory addresses and definitions
     2
     3 				;//---------------------------------------------------------------------------------------------
     4
     5 = 000A			.def DOSVEC			= $000A
     6 = 0012			.def RTCLOK			= $0012	; Real Time Clock
     7
     8 = 0200			.def VDSLST			= $0200	; Display List Interrupt Vector
     9
    10 = 0222			.def VVBLKI			= $0222	; Vertical Blank Immediate (VBI) Register
    11 = 022F			.def SDMCTL			= $022F	; Shadow Direct Memory Access Control address
    12 = 0230			.def SDLSTL			= $0230
    13 = 02C4			.def COLOR0			= $02C4
    14 = 02C5			.def COLOR1			= $02C5
    15 = 02C6			.def COLOR2			= $02C6
    16 = 02C7			.def COLOR3			= $02C7
    17 = 02C8			.def COLOR4			= $02C8
    18 = 02F2			.def CH1			= $02F2
    19 = 02FC			.def CH				= $02FC
    20
    21 = D000			.def HPOSP0          		= $D000	; HORIZONTAL POSITION P0
    22 = D001			.def HPOSP1          		= $D001	; HORIZONTAL POSITION P1
    23 = D002			.def HPOSP2          		= $D002	; HORIZONTAL POSITION P2
    24 = D003			.def HPOSP3          		= $D003	; HORIZONTAL POSITION P3
    25 = D004			.def HPOSM0          		= $D004	; HORIZONTAL POSITION M0
    26 = D005			.def HPOSM1          		= $D005	; HORIZONTAL POSITION M1
    27 = D006			.def HPOSM2          		= $D006	; HORIZONTAL POSITION M2
    28 = D007			.def HPOSM3          		= $D007	; HORIZONTAL POSITION M3
    29 = D008			.def SIZEP0          		= $D008	; SIZE P0
    30 = D009			.def SIZEP1          		= $D009	; SIZE P0
    31 = D00A			.def SIZEP2          		= $D00A	; SIZE P0
    32 = D00B			.def SIZEP3          		= $D00B	; SIZE P0
    33 = D00C			.def SIZEM           		= $D00C	; SIZE M
    34 = D00D			.def GRAFP0          		= $D00D
    35 = D00E			.def GRAFP1          		= $D00E
    36 = D00F			.def GRAFP2          		= $D00F
    37 = D010			.def GRAFP3          		= $D010
    38 = D010			.def TRIG0			= $D010
    39 = D011			.def GRAFM           		= $D011
    40 = D012			.def COLPM0          		= $D012	; COLOR P0/M0
    41 = D013			.def COLPM1          		= $D013	; COLOR P1/M1
    42 = D014			.def COLPM2          		= $D014	; COLOR P2/M2
    43 = D014			.def NTSCPAL         		= $D014
    44 = D015			.def COLPM3          		= $D015	; COLOR P3/M3
    45 = D016			.def COLPF0         		= $D016
    46 = D017			.def COLPF1          		= $D017
    47 = D018			.def COLPF2          		= $D018
    48 = D019			.def COLPF3          		= $D019
    49 = D01A			.def COLBK           		= $D01A
    50 = D01B			.def GPRIOR          		= $D01B
    51 = D01D			.def GRACTL          		= $D01D
    52
    53 = D200			.def POKEY 			= $D200
    54 = D209			.def KBCODE			= $D209
    55 = D20A			.def RANDOM			= $D20A
    56 = D20B			.def POTGO 			= $D20B ; reset paddles for new input to read
    57 = D20E			.def IRQEN          		= $D20E
    58 = D20E			.def IRQST          		= $D20E
    59 = D20F			.def SKCTL			= $D20F
    60 = D20F			.def SKSTAT			= $D20F
    61
    62 = D300			.def PORTA			= $D300
    63 = D301			.def PORTB           		= $D301
    64
    65 = D400			.def DMACTL          		= $D400
    66 = D401			.def CHACTL          		= $D401
    67 = D402			.def DLISTL          		= $D402
    68 = D403			.def DLISTH          		= $D403
    69 = D404			.def HSCROL          		= $D404
    70 = D405			.def VSCROL          		= $D405
    71 = D407			.def PMBASE          		= $D407	; STARTING ADRESS PLAYER MISSILE GRAPHICS
    72 = D409			.def CHBASE          		= $D409
    73 = D40A			.def WSYNC           		= $D40A
    74 = D40B			.def VCOUNT          		= $D40B
    75 = D40E			.def NMIEN          		= $D40E 
    76 = D40F			.def NMIST           		= $D40F
    77 = D40F			.def NMIRES			= $D40F
    78
    79 = FFFA			.def NMI             		= $FFFA
    80 = FFFC			.def RESET           		= $FFFC
    81 = FFFE			.def IRQ             		= $FFFE
    82
    83 				;//---------------------------------------------------------------------------------------------
    84
    85 				.MACRO CHECK_NTSCPAL
    86 						lda		NTSCPAL
    87 						cmp		#1
    88 				.ENDM
    89
    90 				.MACRO SETBKCOL COLVAL
    91 				.ifdef DEBUG_COLOR
    92 						lda		#:COLVAL 
    93 						sta		COLBK
    94 				.endif
    95 				.ENDM
    96
    97 				.MACRO KIL
    98 						dta 2
    99 				.ENDM
   100
   101 				;//---------------------------------------------------------------------------------------------
   102
   103 = 0040			.def LMS                 	= 64
   104 = 0010			.def HS                  	= 16
   105 = 0004			.def MODE4               	= 4
   106 = 000D			.def MODED               	= $0D
   107 = 000E			.def MODEE               	= $0E
   108 = 000F			.def MODEF               	= $0F
   109 = 0070			.def BLANK8              	= $70
   110 = 0080			.def DLI                 	= 128
   111 = 0041			.def DLIJUMP             	= $41	; jump + wait vsync
   112 = 0001			.def DL_JUMP             	= $1	; jump 
   113 = 0000			.def PFSIZE_DISABLED		= 0
   114 = 0001			.def PFSIZE_NARROW		= 1
   115 = 0002			.def PFSIZE_NORMAL		= 2
   116 = 0003			.def PFSIZE_WIDE		= 3
   117 = 0002			.def GRACTL_PDMA		= 1<<1
   118 = 0001			.def GRACTL_MDMA		= 1<<0
    12
    13 				;-----------------
    14
    15 				;//---------------------------------------------------------------------------------------------
    16
    17 				;* ORG addresses can always be changed based on how memory is layed out, as long as it fits, it should work fine
    18
    19 = 0000			ZEROPAGE	equ $0000		; Zeropage, the addresses may be changed if necessary, required
    20 = 0800			DRIVER		equ $0800		; Unrolled LZSS driver by rensoupp, for LZSS data buffer and driver routines, required
    21 					
    22 				;* Below is a bunch of example addreses, they are not intended to be a requirement! 
    23 					
    24 				;SOUNDTEST	equ $2000		; Example program, optional 
    25 				;SONGINDEX	equ $3000		; Songs index and data, alligned memory for easier insertion from RMT, optional 
    26
    27 				;-----------------
    28
    29 				;//---------------------------------------------------------------------------------------------
    30
    31 				;* The Zeropage is a requirement, but could be edited is necessary 
    32
    33 					ORG ZEROPAGE
    34 				.PAGES 1
    35 					icl "lzsspZP.asm"
Source: lzsspZP.asm
     1 				.LOCAL ZPLZS
     2
     3 = 0000			SongPtr    		.ds     2		
     4 = 0002			bit_data        .ds     1
     5
     6 				.ENDL
    36 				.ENDPG
    37
    38 				;-----------------
    39
    40 				;//---------------------------------------------------------------------------------------------
    41
    42 				;* The unrolled LZSS driver + Buffer will be inserted here first, it is a requirement!
    43
    44 					org DRIVER
    45 					icl "playlzs16u.asm"
Source: playlzs16u.asm
     1 				;// code by dmsc, unrolled by rensoupp
     2 				;
     3 				; LZSS Compressed SAP player for 16 match bits
     4 				; --------------------------------------------
     5 				;
     6 				; This player uses:
     7 				;  Match length: 8 bits  (2 to 257)
     8 				;  Match offset: 8 bits  (1 to 256)
     9 				;  Min length: 2
    10 				;  Total match bits: 16 bits
    11 				;
    12
    13 				.ifndef POKEY
    14 				POKEY = $D200
    15 				.endif
    16
    17 				.ifndef LZSS_PLAYER_FIXEDBUF
    18 					.ALIGN $100
    19 				LZSSBuffers
    20 = 0800			    .ds 256 * 9
    21 				.else
    22 				LZSSBuffers = LZSS_PLAYER_FIXEDBUF
    23 				.endif
    24
    25 				//--- macros to grab bytes from compressed stream
    26 				.MACRO GetByteIncY
    27 				    lda     (ZPLZS.SongPtr),y
    28 				    iny
    29 				.ENDM
    30
    31 				.MACRO AddByteIncY
    32 				    adc     (ZPLZS.SongPtr),y     ;// make sure C is clear
    33 				    iny
    34 				.ENDM
    35
    36 				;//##########################################################################
    37 				.LOCAL LZS
    38 = 1100			SongStartPtr        .ds     2
    39 = 1102			SongEndPtr          .ds     2
    40 = 1104			DstBufOffset        .ds     1
    41 = 1105			chn_bitsInit        .ds     1
    42 = 1106			chn_bits            .ds     1
    43 FFFF> 1107-1E32> 00	Initialized         .byte   0
    44 1108 00			DLIDstBufOffset     .byte   0
    45 				.ENDL
    46
    47 				;//##########################################################################
    48 1109			DecodeBufferBytes
    49 				    ; We are decoding a new match/literal
    50 1109 46 02		    lsr     ZPLZS.bit_data    ; Get next bit
    51 110B D0 06		    bne     @got_bit
    52 110D			    GetByteIncY         ; Not enough bits, refill!
Macro: GETBYTEINCY [Source: playlzs16u.asm]
     1 110D B1 00		    lda     (ZPLZS.SongPtr),y
     2 110F C8			    iny
Source: playlzs16u.asm
    53 1110 6A			    ror                 ; Extract a new bit and add a 1 at the high bit (from C set above)
    54 1111 85 02		    sta     ZPLZS.bit_data
    55 1113			@got_bit:
    56 1113			    GetByteIncY         ; Always read a byte, it could mean "match size/offset" or "literal byte"
Macro: GETBYTEINCY [Source: playlzs16u.asm]
     1 1113 B1 00		    lda     (ZPLZS.SongPtr),y
     2 1115 C8			    iny
Source: playlzs16u.asm
    57 1116 60			    rts
    58
    59
    60 				.MACRO DecodeChannel CH_IDX
    61 				    lsr     LZS.chn_bits        ; TODO: use SM code to set a branch ?
    62 				    bcs     skip_chn            ; C=1 : skip this channel
    63 				
    64 				    lda     SMSet_CHRLo+1
    65 				SMSet_CMP    
    66 				    cmp     #$ff                ; (must be reset on init!)
    67 				SMSet_Branch:    
    68 				    bne     CopyStoreCH
    69 				
    70 				    jsr     DecodeBufferBytes
    71 				    bcs     store               ; Bit = 1 is "literal", bit = 0 is "match"
    72 				
    73 				    sta     SMSet_CHRLo+1       ; Store in "copy pos"
    74 				
    75 				    AddByteIncY
    76 				    sta     SMSet_CMP+1  ; Store in "copy length"
    77 				
    78 				CopyStoreCH:
    79 				    inc     SMSet_CHRLo+1
    80 				SMSet_CHRLo    
    81 				    lda     LZSSBuffers+:CH_IDX*256 ; Now, read old data, jump to data store ; (low byte must be reset on init !)
    82 				
    83 				store:
    84 				;    sta     POKEY+:CH_IDX      ; Store to output and buffer
    85 				    sta     LZSSBuffers+:CH_IDX*256,x
    86 				skip_chn    
    87 				.ENDM
    88
    89 				;.print (LblDecodeChannel7-LblDecodeChannel8)
    90 				;.error ((LblDecodeChannel7-LblDecodeChannel8)>32)
    91
    92 				;//##########################################################################
    93 				//--- update song pointer each frame (we can never move more than 255 bytes per frame even at 200hz, max is 3 bytes * 9 channels * 4 updates = 108 bytes )
    94
    95 				// IN Y: ZPLZS.SrcBufOffset
    96 1117			UpdateLZSPtr	
    97 1117 98			    tya
    98 1118 18				clc
    99 1119 65 00			adc	ZPLZS.SongPtr
   100 111B 85 00			sta	ZPLZS.SongPtr
   101 111D 90 02			bcc @NoI
   102 111F E6 01			inc	ZPLZS.SongPtr+1
   103 1121			@NoI	
   104 1121 60				rts
   105
   106 				;//##########################################################################
   107
   108 1122			LZSSReset
   109 1122 A9 01			lda		#1
   110 1124 85 02			sta		ZPLZS.bit_data            ;// bits to decide when to grab new data from the compressed stream
   111 1126 8D 07 11		    sta     LZS.Initialized           ;// flag decoder as initialized
   112 					
   113 				    //--- set song ptr
   114 1129 AD 01 11		    lda     LZS.SongStartPtr+1
   115 112C 85 01		    sta     ZPLZS.SongPtr+1
   116 112E AD 00 11		    lda     LZS.SongStartPtr
   117 1131 85 00		    sta     ZPLZS.SongPtr
   118
   119 				    //--- set dest offset in decompressed streams
   120 1133 A0 00			ldy		#0
   121 1135 8C 04 11		    sty     LZS.DstBufOffset   
   122
   123 				    ;//--- 1st frame of data is at offset 255 (1st frame is always stored uncompressed)
   124 1138 A9 FF		    lda     #255
   125 113A 8D 08 11		    sta     LZS.DLIDstBufOffset     
   126
   127 				    ;// get first byte which contains channels mask
   128 113D			    GetByteIncY
Macro: GETBYTEINCY [Source: playlzs16u.asm]
     1 113D B1 00		    lda     (ZPLZS.SongPtr),y
     2 113F C8			    iny
Source: playlzs16u.asm
   129 1140 8D 05 11		    sta     LZS.chn_bitsInit
   130 1143 8D 06 11		    sta     LZS.chn_bits
   131
   132 				    //--- reset initial value in arrays/decoder code (force CMP test to equal to take the path for decoding new bytes)    
   133 1146 AD FF 11		    lda     DecodeChannel0.SMSet_CHRLo+1
   134 1149 8D EA 11		    sta     DecodeChannel0.SMSet_CMP+1
   135 114C AD 22 12		    lda     DecodeChannel1.SMSet_CHRLo+1
   136 114F 8D 0D 12		    sta     DecodeChannel1.SMSet_CMP+1
   137 1152 AD 45 12		    lda     DecodeChannel2.SMSet_CHRLo+1
   138 1155 8D 30 12		    sta     DecodeChannel2.SMSet_CMP+1
   139 1158 AD 68 12		    lda     DecodeChannel3.SMSet_CHRLo+1
   140 115B 8D 53 12		    sta     DecodeChannel3.SMSet_CMP+1
   141 115E AD 8B 12		    lda     DecodeChannel4.SMSet_CHRLo+1
   142 1161 8D 76 12		    sta     DecodeChannel4.SMSet_CMP+1
   143 1164 AD AE 12		    lda     DecodeChannel5.SMSet_CHRLo+1
   144 1167 8D 99 12		    sta     DecodeChannel5.SMSet_CMP+1
   145 116A AD D1 12		    lda     DecodeChannel6.SMSet_CHRLo+1
   146 116D 8D BC 12		    sta     DecodeChannel6.SMSet_CMP+1
   147 1170 AD F4 12		    lda     DecodeChannel7.SMSet_CHRLo+1
   148 1173 8D DF 12		    sta     DecodeChannel7.SMSet_CMP+1
   149 1176 AD 17 13		    lda     DecodeChannel8.SMSet_CHRLo+1
   150 1179 8D 02 13		    sta     DecodeChannel8.SMSet_CMP+1
   151
   152 117C A9 10		    lda     #.HI(LZSSBuffers+$100*8)
   153 117E 8D 92 11		    sta     @SMSet_LZSSBuf+2
   154
   155 1181 A2 08		    ldx #9-1
   156 				    
   157 1183			@SetFirstFrame 
   158 1183			    GetByteIncY   
Macro: GETBYTEINCY [Source: playlzs16u.asm]
     1 1183 B1 00		    lda     (ZPLZS.SongPtr),y
     2 1185 C8			    iny
Source: playlzs16u.asm
   159
   160 1186 4E 06 11		    lsr     LZS.chn_bits
   161 1189 90 05		    bcc     @DontSetPokey
   162 				    
   163 				;	sta     POKEY,x                 ;// channel was not compressed, write to Pokey just once
   164 118B 9D 45 15		    sta SDWPOK0,x			;// edit by VinsCool: write to POKEY buffer for VUPlayer's timing and VUMeter display
   165 				    
   166 118E B0 03		    bcs     @DontSetBuffer
   167 1190			@DontSetPokey    
   168 1190			@SMSet_LZSSBuf    
   169 1190 8D FF 10		    sta     LZSSBuffers+$100*8+255    ;// channel was compressed, write first value at offset 255
   170 1193			@DontSetBuffer    
   171 1193 CE 92 11		    dec     @SMSet_LZSSBuf+2        ;// next buffer
   172 1196 CA			    dex 
   173 1197 10 EA		    bpl     @SetFirstFrame
   174 				    
   175 				    //--- update src stream ptr
   176 1199 20 17 11			jsr     UpdateLZSPtr
   177 				    //---
   178 				;    jmp     CreateChannelSkipCode       
   179
   180 				;//-------------------------------------------------------------------------
   181 				;//--- called during song reset to modify NMI code that sends data to pokey
   182 				;//--- this changes writes to pokey (STA) to reads (LDA) when channels are skipped - could be a problem when reading POT stuff ????
   183
   184
   185 119C			CreateChannelSkipCode
   186 119C			.LOCAL
   187 119C AD 05 11		    lda     LZS.chn_bitsInit
   188
   189 119F			SMSet_chn_bitsInit
   190 119F C9 00		    cmp     #0
   191 11A1 F0 1E		    beq     NoNeedToReinit          ;// same mask as previous song
   192 11A3 8D A0 11		    sta     SMSet_chn_bitsInit+1
   193 11A6 8D 06 11		    sta     LZS.chn_bits
   194
   195 11A9 A2 07		    ldx     #9-1-1
   196 11AB A0 00		    ldy     #0
   197
   198 11AD			NextChannel
   199 11AD A9 8D		    lda     #$8D    ;// STA ABS
   200 11AF 0E 06 11		    asl     LZS.chn_bits
   201 11B2 90 03		    bcc     @WriteChannel
   202 11B4 A9 AD		    lda     #$AD    ;// LDA ABS     ;// change the write to pokey to a read 
   203 11B6 18			    clc
   204 11B7			@WriteChannel
   205 11B7 99 49 13		    sta     SMSet_WritePokey0,y
   206
   207 11BA 98			    tya
   208 11BB 69 06		    adc     #SMSet_WritePokey1-SMSet_WritePokey0
   209 11BD A8			    tay
   210
   211 11BE CA			    dex
   212 11BF 10 EC		    bpl     NextChannel
   213 11C1			NoNeedToReinit
   214 11C1 60			    rts
   215 				.ENDL
   216
   217 				;//##########################################################################
   218 				;//--- Method 1: play a single update for the current frame 
   219 				;//--- when CPU usage isn't important and it's ok to poll VCOUNT to wait for the next update
   220
   221 11C2			LZSSPlayFrame:    
   222 11C2 AD 04 11		    lda     LZS.DstBufOffset
   223 11C5 8D 08 11		    sta     LZS.DLIDstBufOffset
   224
   225 11C8 A2 01		    ldx     #1
   226 11CA AD 07 11		    lda     LZS.Initialized
   227 11CD D0 04		    bne     LZSSPlay1Frame
   228 				    //--- (re)init song 
   229 11CF 20 22 11		    jsr     LZSSReset
   230 11D2 60			    rts
   231
   232
   233 				;//##########################################################################
   234 				;//--- Method 2: play all updates for the current frame (depending on song speed)
   235 				;//--- should be called at during VBI, so that only Pokey register updates are done during DLis
   236
   237 				/*
   238 				LZSSPlayFrames:    
   239 				    lda     LZS.DstBufOffset
   240 				    sta     LZS.DLIDstBufOffset
   241
   242 				    ldx     SongSpeed
   243
   244 					lda		LZS.Initialized
   245 					bne		@Initialized
   246 				    //--- (re)init song 
   247 				    jsr     LZSSReset
   248 				    //--- have multiple pokey frames to play ?
   249 				    ldx     SongSpeed
   250 				    dex
   251 				    bne     @Initialized
   252 				    rts
   253 				*/
   253
   254
   255 11D3			@Initialized
   256
   257
   258 11D3			LZSSPlay1Frame
   259 11D3 8E 23 13		    stx     SMSet_PlayCounter+1
   260
   261 11D6 AE 04 11		    ldx     LZS.DstBufOffset
   262
   263 11D9 AD 05 11		    lda     LZS.chn_bitsInit
   264 11DC 8D 06 11		    sta     LZS.chn_bits
   265 				    
   266 11DF A0 00			ldy     #0     ;// source offset in compressed data
   267 				    
   268 				    ; Loop through all "channels", one for each POKEY register
   269
   270 11E1			LblDecodeChannel8
   271 11E1			    DecodeChannel 8
Macro: DECODECHANNEL [Source: playlzs16u.asm]
     1 11E1 4E 06 11		    lsr     LZS.chn_bits        ; TODO: use SM code to set a branch ?
     2 11E4 B0 1E		    bcs     skip_chn            ; C=1 : skip this channel
     4 11E6 AD FF 11		    lda     SMSet_CHRLo+1
     5 11E9			SMSet_CMP    
     6 11E9 C9 FF		    cmp     #$ff                ; (must be reset on init!)
     7 11EB			SMSet_Branch:    
     8 11EB D0 0E		    bne     CopyStoreCH
    10 11ED 20 09 11		    jsr     DecodeBufferBytes
    11 11F0 B0 0F		    bcs     store               ; Bit = 1 is "literal", bit = 0 is "match"
    13 11F2 8D FF 11		    sta     SMSet_CHRLo+1       ; Store in "copy pos"
     1 11F5 71 00		    adc     (ZPLZS.SongPtr),y     ;// make sure C is clear
     2 11F7 C8			    iny
Source: playlzs16u.asm
    16 11F8 8D EA 11		    sta     SMSet_CMP+1  ; Store in "copy length"
    18 11FB			CopyStoreCH:
    19 11FB EE FF 11		    inc     SMSet_CHRLo+1
    20 11FE			SMSet_CHRLo    
    21 11FE AD 00 10		    lda     LZSSBuffers+8*256 ; Now, read old data, jump to data store ; (low byte must be reset on init !)
    23 1201			store:
    25 1201 9D 00 10		    sta     LZSSBuffers+8*256,x
    26 1204			skip_chn    
Source: playlzs16u.asm
   272 1204			LblDecodeChannel7    
   273 1204			    DecodeChannel 7
Macro: DECODECHANNEL [Source: playlzs16u.asm]
     1 1204 4E 06 11		    lsr     LZS.chn_bits        ; TODO: use SM code to set a branch ?
     2 1207 B0 1E		    bcs     skip_chn            ; C=1 : skip this channel
     4 1209 AD 22 12		    lda     SMSet_CHRLo+1
     5 120C			SMSet_CMP    
     6 120C C9 FF		    cmp     #$ff                ; (must be reset on init!)
     7 120E			SMSet_Branch:    
     8 120E D0 0E		    bne     CopyStoreCH
    10 1210 20 09 11		    jsr     DecodeBufferBytes
    11 1213 B0 0F		    bcs     store               ; Bit = 1 is "literal", bit = 0 is "match"
    13 1215 8D 22 12		    sta     SMSet_CHRLo+1       ; Store in "copy pos"
     1 1218 71 00		    adc     (ZPLZS.SongPtr),y     ;// make sure C is clear
     2 121A C8			    iny
Source: playlzs16u.asm
    16 121B 8D 0D 12		    sta     SMSet_CMP+1  ; Store in "copy length"
    18 121E			CopyStoreCH:
    19 121E EE 22 12		    inc     SMSet_CHRLo+1
    20 1221			SMSet_CHRLo    
    21 1221 AD 00 0F		    lda     LZSSBuffers+7*256 ; Now, read old data, jump to data store ; (low byte must be reset on init !)
    23 1224			store:
    25 1224 9D 00 0F		    sta     LZSSBuffers+7*256,x
    26 1227			skip_chn    
Source: playlzs16u.asm
   274 1227			    DecodeChannel 6
Macro: DECODECHANNEL [Source: playlzs16u.asm]
     1 1227 4E 06 11		    lsr     LZS.chn_bits        ; TODO: use SM code to set a branch ?
     2 122A B0 1E		    bcs     skip_chn            ; C=1 : skip this channel
     4 122C AD 45 12		    lda     SMSet_CHRLo+1
     5 122F			SMSet_CMP    
     6 122F C9 FF		    cmp     #$ff                ; (must be reset on init!)
     7 1231			SMSet_Branch:    
     8 1231 D0 0E		    bne     CopyStoreCH
    10 1233 20 09 11		    jsr     DecodeBufferBytes
    11 1236 B0 0F		    bcs     store               ; Bit = 1 is "literal", bit = 0 is "match"
    13 1238 8D 45 12		    sta     SMSet_CHRLo+1       ; Store in "copy pos"
     1 123B 71 00		    adc     (ZPLZS.SongPtr),y     ;// make sure C is clear
     2 123D C8			    iny
Source: playlzs16u.asm
    16 123E 8D 30 12		    sta     SMSet_CMP+1  ; Store in "copy length"
    18 1241			CopyStoreCH:
    19 1241 EE 45 12		    inc     SMSet_CHRLo+1
    20 1244			SMSet_CHRLo    
    21 1244 AD 00 0E		    lda     LZSSBuffers+6*256 ; Now, read old data, jump to data store ; (low byte must be reset on init !)
    23 1247			store:
    25 1247 9D 00 0E		    sta     LZSSBuffers+6*256,x
    26 124A			skip_chn    
Source: playlzs16u.asm
   275 124A			    DecodeChannel 5
Macro: DECODECHANNEL [Source: playlzs16u.asm]
     1 124A 4E 06 11		    lsr     LZS.chn_bits        ; TODO: use SM code to set a branch ?
     2 124D B0 1E		    bcs     skip_chn            ; C=1 : skip this channel
     4 124F AD 68 12		    lda     SMSet_CHRLo+1
     5 1252			SMSet_CMP    
     6 1252 C9 FF		    cmp     #$ff                ; (must be reset on init!)
     7 1254			SMSet_Branch:    
     8 1254 D0 0E		    bne     CopyStoreCH
    10 1256 20 09 11		    jsr     DecodeBufferBytes
    11 1259 B0 0F		    bcs     store               ; Bit = 1 is "literal", bit = 0 is "match"
    13 125B 8D 68 12		    sta     SMSet_CHRLo+1       ; Store in "copy pos"
     1 125E 71 00		    adc     (ZPLZS.SongPtr),y     ;// make sure C is clear
     2 1260 C8			    iny
Source: playlzs16u.asm
    16 1261 8D 53 12		    sta     SMSet_CMP+1  ; Store in "copy length"
    18 1264			CopyStoreCH:
    19 1264 EE 68 12		    inc     SMSet_CHRLo+1
    20 1267			SMSet_CHRLo    
    21 1267 AD 00 0D		    lda     LZSSBuffers+5*256 ; Now, read old data, jump to data store ; (low byte must be reset on init !)
    23 126A			store:
    25 126A 9D 00 0D		    sta     LZSSBuffers+5*256,x
    26 126D			skip_chn    
Source: playlzs16u.asm
   276 126D			    DecodeChannel 4
Macro: DECODECHANNEL [Source: playlzs16u.asm]
     1 126D 4E 06 11		    lsr     LZS.chn_bits        ; TODO: use SM code to set a branch ?
     2 1270 B0 1E		    bcs     skip_chn            ; C=1 : skip this channel
     4 1272 AD 8B 12		    lda     SMSet_CHRLo+1
     5 1275			SMSet_CMP    
     6 1275 C9 FF		    cmp     #$ff                ; (must be reset on init!)
     7 1277			SMSet_Branch:    
     8 1277 D0 0E		    bne     CopyStoreCH
    10 1279 20 09 11		    jsr     DecodeBufferBytes
    11 127C B0 0F		    bcs     store               ; Bit = 1 is "literal", bit = 0 is "match"
    13 127E 8D 8B 12		    sta     SMSet_CHRLo+1       ; Store in "copy pos"
     1 1281 71 00		    adc     (ZPLZS.SongPtr),y     ;// make sure C is clear
     2 1283 C8			    iny
Source: playlzs16u.asm
    16 1284 8D 76 12		    sta     SMSet_CMP+1  ; Store in "copy length"
    18 1287			CopyStoreCH:
    19 1287 EE 8B 12		    inc     SMSet_CHRLo+1
    20 128A			SMSet_CHRLo    
    21 128A AD 00 0C		    lda     LZSSBuffers+4*256 ; Now, read old data, jump to data store ; (low byte must be reset on init !)
    23 128D			store:
    25 128D 9D 00 0C		    sta     LZSSBuffers+4*256,x
    26 1290			skip_chn    
Source: playlzs16u.asm
   277 1290			    DecodeChannel 3
Macro: DECODECHANNEL [Source: playlzs16u.asm]
     1 1290 4E 06 11		    lsr     LZS.chn_bits        ; TODO: use SM code to set a branch ?
     2 1293 B0 1E		    bcs     skip_chn            ; C=1 : skip this channel
     4 1295 AD AE 12		    lda     SMSet_CHRLo+1
     5 1298			SMSet_CMP    
     6 1298 C9 FF		    cmp     #$ff                ; (must be reset on init!)
     7 129A			SMSet_Branch:    
     8 129A D0 0E		    bne     CopyStoreCH
    10 129C 20 09 11		    jsr     DecodeBufferBytes
    11 129F B0 0F		    bcs     store               ; Bit = 1 is "literal", bit = 0 is "match"
    13 12A1 8D AE 12		    sta     SMSet_CHRLo+1       ; Store in "copy pos"
     1 12A4 71 00		    adc     (ZPLZS.SongPtr),y     ;// make sure C is clear
     2 12A6 C8			    iny
Source: playlzs16u.asm
    16 12A7 8D 99 12		    sta     SMSet_CMP+1  ; Store in "copy length"
    18 12AA			CopyStoreCH:
    19 12AA EE AE 12		    inc     SMSet_CHRLo+1
    20 12AD			SMSet_CHRLo    
    21 12AD AD 00 0B		    lda     LZSSBuffers+3*256 ; Now, read old data, jump to data store ; (low byte must be reset on init !)
    23 12B0			store:
    25 12B0 9D 00 0B		    sta     LZSSBuffers+3*256,x
    26 12B3			skip_chn    
Source: playlzs16u.asm
   278 12B3			    DecodeChannel 2
Macro: DECODECHANNEL [Source: playlzs16u.asm]
     1 12B3 4E 06 11		    lsr     LZS.chn_bits        ; TODO: use SM code to set a branch ?
     2 12B6 B0 1E		    bcs     skip_chn            ; C=1 : skip this channel
     4 12B8 AD D1 12		    lda     SMSet_CHRLo+1
     5 12BB			SMSet_CMP    
     6 12BB C9 FF		    cmp     #$ff                ; (must be reset on init!)
     7 12BD			SMSet_Branch:    
     8 12BD D0 0E		    bne     CopyStoreCH
    10 12BF 20 09 11		    jsr     DecodeBufferBytes
    11 12C2 B0 0F		    bcs     store               ; Bit = 1 is "literal", bit = 0 is "match"
    13 12C4 8D D1 12		    sta     SMSet_CHRLo+1       ; Store in "copy pos"
     1 12C7 71 00		    adc     (ZPLZS.SongPtr),y     ;// make sure C is clear
     2 12C9 C8			    iny
Source: playlzs16u.asm
    16 12CA 8D BC 12		    sta     SMSet_CMP+1  ; Store in "copy length"
    18 12CD			CopyStoreCH:
    19 12CD EE D1 12		    inc     SMSet_CHRLo+1
    20 12D0			SMSet_CHRLo    
    21 12D0 AD 00 0A		    lda     LZSSBuffers+2*256 ; Now, read old data, jump to data store ; (low byte must be reset on init !)
    23 12D3			store:
    25 12D3 9D 00 0A		    sta     LZSSBuffers+2*256,x
    26 12D6			skip_chn    
Source: playlzs16u.asm
   279 12D6			    DecodeChannel 1
Macro: DECODECHANNEL [Source: playlzs16u.asm]
     1 12D6 4E 06 11		    lsr     LZS.chn_bits        ; TODO: use SM code to set a branch ?
     2 12D9 B0 1E		    bcs     skip_chn            ; C=1 : skip this channel
     4 12DB AD F4 12		    lda     SMSet_CHRLo+1
     5 12DE			SMSet_CMP    
     6 12DE C9 FF		    cmp     #$ff                ; (must be reset on init!)
     7 12E0			SMSet_Branch:    
     8 12E0 D0 0E		    bne     CopyStoreCH
    10 12E2 20 09 11		    jsr     DecodeBufferBytes
    11 12E5 B0 0F		    bcs     store               ; Bit = 1 is "literal", bit = 0 is "match"
    13 12E7 8D F4 12		    sta     SMSet_CHRLo+1       ; Store in "copy pos"
     1 12EA 71 00		    adc     (ZPLZS.SongPtr),y     ;// make sure C is clear
     2 12EC C8			    iny
Source: playlzs16u.asm
    16 12ED 8D DF 12		    sta     SMSet_CMP+1  ; Store in "copy length"
    18 12F0			CopyStoreCH:
    19 12F0 EE F4 12		    inc     SMSet_CHRLo+1
    20 12F3			SMSet_CHRLo    
    21 12F3 AD 00 09		    lda     LZSSBuffers+1*256 ; Now, read old data, jump to data store ; (low byte must be reset on init !)
    23 12F6			store:
    25 12F6 9D 00 09		    sta     LZSSBuffers+1*256,x
    26 12F9			skip_chn    
Source: playlzs16u.asm
   280 12F9			    DecodeChannel 0
Macro: DECODECHANNEL [Source: playlzs16u.asm]
     1 12F9 4E 06 11		    lsr     LZS.chn_bits        ; TODO: use SM code to set a branch ?
     2 12FC B0 1E		    bcs     skip_chn            ; C=1 : skip this channel
     4 12FE AD 17 13		    lda     SMSet_CHRLo+1
     5 1301			SMSet_CMP    
     6 1301 C9 FF		    cmp     #$ff                ; (must be reset on init!)
     7 1303			SMSet_Branch:    
     8 1303 D0 0E		    bne     CopyStoreCH
    10 1305 20 09 11		    jsr     DecodeBufferBytes
    11 1308 B0 0F		    bcs     store               ; Bit = 1 is "literal", bit = 0 is "match"
    13 130A 8D 17 13		    sta     SMSet_CHRLo+1       ; Store in "copy pos"
     1 130D 71 00		    adc     (ZPLZS.SongPtr),y     ;// make sure C is clear
     2 130F C8			    iny
Source: playlzs16u.asm
    16 1310 8D 02 13		    sta     SMSet_CMP+1  ; Store in "copy length"
    18 1313			CopyStoreCH:
    19 1313 EE 17 13		    inc     SMSet_CHRLo+1
    20 1316			SMSet_CHRLo    
    21 1316 AD 00 08		    lda     LZSSBuffers+0*256 ; Now, read old data, jump to data store ; (low byte must be reset on init !)
    23 1319			store:
    25 1319 9D 00 08		    sta     LZSSBuffers+0*256,x
    26 131C			skip_chn    
Source: playlzs16u.asm
   281 131C 20 17 11		    jsr     UpdateLZSPtr
   282
   283 131F EE 04 11		    inc     LZS.DstBufOffset
   284
   285 1322			SMSet_PlayCounter
   286 1322 A2 FF		    ldx     #$ff
   287 1324 CA			    dex
   288 1325 F0 03		    beq     @NoMoreFrame
   289 1327 4C D3 11		    jmp     LZSSPlay1Frame
   290 132A			@NoMoreFrame
   291 132A 60			    rts
   292
   293 				;//##########################################################################
   294 				;//--- out Z flag: clear = end of song
   295
   296 132B			LZSSCheckEndOfSong
   297 				    //--- check end of song
   298 132B A5 01		    lda     ZPLZS.SongPtr + 1
   299 132D CD 03 11		    cmp     LZS.SongEndPtr+1
   300 1330 D0 07		    bne     @NotEnd
   301 1332 A5 00		    lda     ZPLZS.SongPtr
   302 1334 CD 02 11		    cmp     LZS.SongEndPtr
   303 1337 D0 00		    bne     @NotEnd
   304 1339			@NotEnd    
   305 1339 60			    rts
   306
   307 				;//##########################################################################
   308 				//--- send decompressed data to pokey
   309
   310 133A			LZSSUpdatePokeyRegisters
   311 				    //--- get offset into decoded buffers where lasts bytes were written to
   312 133A AE 08 11		    ldx     LZS.DLIDstBufOffset
   313 133D EE 08 11		    inc     LZS.DLIDstBufOffset
   314
   315 				    ;//--- always update first register because always part of the compressed data
   316 1340 BD 00 08		    lda    LZSSBuffers+0*256,x   
   317 				       
   318 				;	sta    POKEY+0
   319 1343 8D 45 15		    sta SDWPOK0				;// edit by VinsCool: write to POKEY buffer for VUPlayer's timing and VUMeter display
   320 				    
   321 				    //---
   322 1346			UpdatePokeyRegisters1
   323 				.REPT 8 #
   324 				    LDA    LZSSBUFFERS+(#+1)*256,X    
   325 				SMSET_WRITEPOKEY:1
   328 				    STA SDWPOK0+(#+1) 			
   330 				.ENDR  
   330 				.ENDR  
Source: REPT
   324 1346 BD 00 09		    LDA    LZSSBUFFERS+(#+1)*256,X    
   324 1349			SMSET_WRITEPOKEY0
   324 1349 8D 46 15		    STA SDWPOK0+(#+1) 			
   324 134C BD 00 0A		    LDA    LZSSBUFFERS+(#+1)*256,X    
   324 134F			SMSET_WRITEPOKEY1
   324 134F 8D 47 15		    STA SDWPOK0+(#+1) 			
   324 1352 BD 00 0B		    LDA    LZSSBUFFERS+(#+1)*256,X    
   324 1355			SMSET_WRITEPOKEY2
   324 1355 8D 48 15		    STA SDWPOK0+(#+1) 			
   324 1358 BD 00 0C		    LDA    LZSSBUFFERS+(#+1)*256,X    
   324 135B			SMSET_WRITEPOKEY3
   324 135B 8D 49 15		    STA SDWPOK0+(#+1) 			
   324 135E BD 00 0D		    LDA    LZSSBUFFERS+(#+1)*256,X    
   324 1361			SMSET_WRITEPOKEY4
   324 1361 8D 4A 15		    STA SDWPOK0+(#+1) 			
   324 1364 BD 00 0E		    LDA    LZSSBUFFERS+(#+1)*256,X    
   324 1367			SMSET_WRITEPOKEY5
   324 1367 8D 4B 15		    STA SDWPOK0+(#+1) 			
   324 136A BD 00 0F		    LDA    LZSSBUFFERS+(#+1)*256,X    
   324 136D			SMSET_WRITEPOKEY6
   324 136D 8D 4C 15		    STA SDWPOK0+(#+1) 			
   324 1370 BD 00 10		    LDA    LZSSBUFFERS+(#+1)*256,X    
   324 1373			SMSET_WRITEPOKEY7
   324 1373 8D 4D 15		    STA SDWPOK0+(#+1) 			
Source: playlzs16u.asm
   331
   332 1376 60			    rts  
   333
   334
    46
    47 				;-----------------
    48
    49 				;//---------------------------------------------------------------------------------------------
    50 				               
    51 				;* Several subroutines added for VUPlayer have been split to become part of the driver itself, allowing new features for future projects easily!
    52
    53 				;-----------------
    54
    55 				;* Song index initialisation subroutine, load pointers using index number, as well as loop point when it exists 
    56 				           
    57 1377			SetNewSongPtrsFull 			; if the routine is called from this label, index and loop are restarted
    58 1377 A2 00			ldx #0
    59 1379 8E DE 13			stx is_fadeing_out		; reset fadeout flag, the new index is loaded from start
    60 137C 8E A3 13			stx is_looping 			; reset the loop counter, the new index is loaded from start 
    61 137F 8E B9 13			stx loop_count
    62 1382 A9 00			lda #0				; current tune index, must be set before the routine is executed
    63 = 1383				SongIdx equ *-1 
    64 1384 0A				asl @				; multiply by 2, for the hi and lo bytes of each address 
    65 1385 0A				asl @				; multiply again, offset each songs by 4 bytes
    66 1386 AA				tax 
    67 1387 BD 33 1E			lda SongIndex,x
    68 138A 8D C9 13			sta SongPtr+0
    69 138D E8				inx 
    70 138E BD 33 1E			lda SongIndex,x
    71 1391 8D CA 13			sta SongPtr+1
    72 1394 E8				inx 
    73 1395 BD 33 1E			lda SongIndex,x
    74 1398 8D A5 13			sta SectionPtr+0
    75 139B E8				inx 
    76 139C BD 33 1E			lda SongIndex,x
    77 139F 8D A6 13			sta SectionPtr+1
    78 					
    79 13A2			SetNewSongPtrs 				; if the routine is called from this label, it will use the current parameters instead 
    80 13A2 A0 00			ldy #0 
    81 = 13A3				is_looping equ *-1 
    82 13A4 B9 FF FF			lda $FFFF,y
    83 = 13A5				SectionPtr equ *-2 
    84 13A7 10 1B			bpl SetNewSongPtrs_c
    85 					
    86 13A9			SetNewSongPtrs_a
    87 13A9 C9 FF			cmp #$FF
    88 13AB D0 03			bne SetNewSongPtrs_b
    89 13AD 4C 26 14			jmp stop_toggle
    90
    91 13B0			SetNewSongPtrs_b
    92 13B0 29 7F			and #$7F
    93 13B2 8D A3 13			sta is_looping
    94 				;	bpl SetNewSongPtrs
    95 13B5 EE B9 13			inc loop_count
    96 13B8 A9 00			lda #0
    97 = 13B9				loop_count equ *-1
    98 13BA C9 02			cmp #2
    99 13BC D0 E4			bne SetNewSongPtrs
   100 13BE 20 D5 14			jsr trigger_fade_immediate
   101 13C1 4C A2 13			jmp SetNewSongPtrs
   102
   103 13C4			SetNewSongPtrs_c	
   104 13C4 0A				asl @
   105 13C5 AA				tax
   106 13C6 A0 00			ldy #0
   107 					
   108 13C8			SetNewSongPtrs_d
   109 13C8 BD FF FF			lda $FFFF,x
   110 = 13C9				SongPtr equ *-2
   111 13CB 99 00 11			sta LZS.SongStartPtr,y
   112 13CE E8				inx
   113 13CF C8				iny
   114 13D0 C0 04			cpy #4
   115 13D2 90 F4			bcc SetNewSongPtrs_d
   116 13D4 EE A3 13			inc is_looping 
   117
   118 13D7			SetNewSongPtrsDone
   119 13D7 A9 00			lda #0
   120 13D9 8D 07 11			sta LZS.Initialized		; reset the state of the LZSS driver to not initialised so it can play the next tune or loop 
   121 13DC 60				rts 	
   122
   123 				;-----------------
   124
   125 				;* Volume fadeout subroutine
   126
   127 13DD			fade_volume_loop 
   128 13DD A9 00			lda #0			; fadeing out timer and flag
   129 = 13DE				is_fadeing_out equ *-1 
   130 13DF F0 37			beq fade_volume_done	; equal 0 means it is not set, and must be skipped
   131 13E1 10 0B			bpl continue_fadeout	; above 0 means it is already set, skip initialising again 
   132 13E3			begin_fadeout			; below 0 means it is set, and must be initialised first 
   133 13E3 A9 01			lda #1			; unit of volume to subtract
   134 13E5 8D DE 13			sta is_fadeing_out	; flag and initial fade volume set
   135 13E8 AD F7 14			lda v_second		; current second
   136 13EB 8D 15 14			sta last_second_seen	; initialise the timer for fadeout
   137 13EE			continue_fadeout	
   138 13EE A0 07			ldy #7			; index from the 4th AUDC 
   139 13F0			fade_volume_loop_a
   140 13F0 B9 45 15			lda SDWPOK0,y		; current POKEY buffer
   141 13F3 AA				tax			; backup for the next step
   142 13F4 29 0F			and #$0F		; keep only the volume values
   143 13F6 38				sec			; set carry for the subtraction
   144 13F7 ED DE 13			sbc is_fadeing_out	; subtract the fading value directly
   145 13FA F0 0E			beq volume_loop_again	; if value = 0, write that value directly
   146 13FC 10 04			bpl set_new_volume	; else if the subtraction did not overflow, continue with the next step
   147 13FE A9 00			lda #0			; else, set the volume to 0 
   148 1400 F0 08			beq volume_loop_again	; unconditional 
   149 1402			set_new_volume	
   150 1402 8D 09 14			sta ora_volume		; this value will be used for the ORA instruction 
   151 1405 8A				txa			; get back the AUDC value loaded a moment before
   152 1406 29 F0			and #$F0		; only keep the Distortion bits
   153 1408 09 00			ora #0			; combine the new volume to it
   154 = 1409				ora_volume equ *-1
   155 140A			volume_loop_again
   156 140A 99 45 15			sta SDWPOK0,y		; write the new AUDC value in memory for later
   157 140D 88 88			:2 dey			; decrement twice to only load the AUDC
   158 140F 10 DF			bpl fade_volume_loop_a	; continue this loop until Y overflows to $FF 
   159 1411 AD F7 14			lda v_second		; current second count
   160 1414 C9 00			cmp #0			; compare to the last second loaded 
   161 = 1415				last_second_seen equ *-1
   162 1416 D0 01			bne fade_increment
   163 1418			fade_volume_done
   164 1418 60				rts
   165 1419			fade_increment
   166 1419 8D 15 14			sta last_second_seen
   167 141C EE DE 13			inc is_fadeing_out	; increment the fadeout value to subtract by 1 
   168 141F AD DE 13			lda is_fadeing_out	; load that value for the comparison 
   169 1422 C9 0B			cmp #11			; 10 seconds must have passed to reach 10 units
   170 1424 90 F2			bcc fade_volume_done	; if the value is below the count, done 
   171
   172 				;-----------------
   173
   174 				;* Toggle Stop, similar to pause, except Play will restart the tune from the beginning
   175 				;* The routine will continue into the following subroutines, a RTS will be found at the end of setpokeyfull further below 
   176
   177 1426			stop_toggle 
   178 1426 AD C3 14			lda is_playing_flag 
   179 1429 10 01			bpl set_stop			; the Stop flag will be set, regardless of Playing or being Paused 
   180 142B 60				rts				; otherwise, the player is stopped already 
   181 142C			set_stop
   182 142C A9 FF			lda #$FF
   183 142E 8D C3 14			sta is_playing_flag		; #$FF -> Stop
   184 1431 20 77 13			jsr SetNewSongPtrsFull 		; TODO: fix the index code, the tune won't restart properly  
   185 1434 20 10 15			jsr reset_timer 		; clear the timer, unlike PAUSE, which would freeze the values until it is unpaused
   186 					
   187 				;-----------------
   188
   189 				;* Stop/Pause the player and reset the POKEY registers, a RTS will be found at the end of setpokeyfull further below 
   190
   191 1437			stop_pause_reset
   192 1437 A9 00			lda #0			; default values
   193 1439 A0 08			ldy #8
   194 143B			stop_pause_reset_a 
   195 143B 99 45 15			sta SDWPOK0,y		; clear the POKEY values in memory 
   196 143E 99 4F 15			sta SDWPOK1,y
   197 1441 88				dey 
   198 1442 10 F7			bpl stop_pause_reset_a	; repeat until all channels were cleared 
   199
   200 				;----------------- 
   201
   202 				;* Setpokey, intended for double buffering the decompressed LZSS bytes as fast as possible for timing and cosmetic purpose
   203
   204 1444			setpokeyfull
   205 1444 AD 4E 15			lda POKSKC0 
   206 1447 8D 0F D2			sta $D20F 
   207 144A AC 4D 15			ldy POKCTL0
   208 144D AD 45 15			lda POKF0
   209 1450 AE 46 15			ldx POKC0
   210 1453 8D 00 D2			sta $D200
   211 1456 8E 01 D2			stx $D201
   212 1459 AD 47 15			lda POKF1
   213 145C AE 48 15			ldx POKC1
   214 145F 8D 02 D2			sta $D202
   215 1462 8E 03 D2			stx $D203
   216 1465 AD 49 15			lda POKF2
   217 1468 AE 4A 15			ldx POKC2
   218 146B 8D 04 D2			sta $D204
   219 146E 8E 05 D2			stx $D205
   220 1471 AD 4B 15			lda POKF3
   221 1474 AE 4C 15			ldx POKC3
   222 1477 8D 06 D2			sta $D206
   223 147A 8E 07 D2			stx $D207
   224 147D 8C 08 D2			sty $D208
   225
   226 				;* 0 == Mono, FF == Stereo, 1 == Dual Mono (only SwapBuffer is necessary for it) 
   227
   228 1480 A9 01			lda #STEREO
   229 = 1481				is_stereo_flag equ *-1
   230 1482 D0 01			bne setpokeyfullstereo
   231 1484 60				rts
   232
   233 1485			setpokeyfullstereo
   234 1485 AD 58 15			lda POKSKC1 
   235 1488 8D 1F D2			sta $D21F 
   236 148B AC 57 15			ldy POKCTL1
   237 148E AD 4F 15			lda POKF4
   238 1491 AE 50 15			ldx POKC4
   239 1494 8D 10 D2			sta $D210
   240 1497 8E 11 D2			stx $D211
   241 149A AD 51 15			lda POKF5
   242 149D AE 52 15			ldx POKC5
   243 14A0 8D 12 D2			sta $D212
   244 14A3 8E 13 D2			stx $D213
   245 14A6 AD 53 15			lda POKF6
   246 14A9 AE 54 15			ldx POKC6
   247 14AC 8D 14 D2			sta $D214
   248 14AF 8E 15 D2			stx $D215
   249 14B2 AD 55 15			lda POKF7
   250 14B5 AE 56 15			ldx POKC7
   251 14B8 8D 16 D2			sta $D216
   252 14BB 8E 17 D2			stx $D217
   253 14BE 8C 18 D2			sty $D218
   254 14C1 60				rts
   255
   256 				;-----------------
   257
   258 				; Toggle Play/Pause 
   259
   260 14C2			play_pause_toggle 
   261 14C2 A9 00			lda #0
   262 = 14C3				is_playing_flag equ *-1 	; #0 -> Play, #1 -> Pause, #$FF -> Stop 
   263 14C4 F0 09			beq set_pause	
   264 14C6			set_play 
   265 14C6 A9 00			lda #0				; reset the Play flag, regardless of being Paused or Stopped  
   266 14C8 8D C3 14			sta is_playing_flag		; #0 -> Play
   267 14CB 8D DE 13			sta is_fadeing_out		; reset the fadeing out flag, in case it was set before pausing 
   268 14CE 60				rts
   269 14CF			set_pause 
   270 14CF EE C3 14			inc is_playing_flag		; #0 -> #1 -> Pause 
   271 14D2 4C 37 14			jmp stop_pause_reset		; clear the POKEY registers, end with a RTS
   272 					
   273 				;-----------------
   274
   275 				;* This routine provides the ability to initialise a fadeout for anything that may require a transition in a game/demo 
   276 				;* At the end of the routine, the is_playing flag will be set to a 'stop', which will indicate the fadeout has been completed
   277 				;* If a new tune index is loaded during a fadeout, it will be interrupted, and play the next tune like normal instead 
   278 					
   279 14D5			trigger_fade_immediate 
   280 14D5 AD C3 14			lda is_playing_flag	; is the player currently in 'play' mode? 
   281 14D8 D0 08			bne trigger_fade_done	; if not, skip this subroutine, there is nothing to fadeout 
   282 14DA AD DE 13			lda is_fadeing_out	; is the tune currently playing already engaged in a fadeout?
   283 14DD D0 03			bne trigger_fade_done	; if not 0, there is a fadeout in progress! skip this subroutine
   284 14DF CE DE 13			dec is_fadeing_out	; $00 -> $FF, the fadeout flag is set
   285 14E2			trigger_fade_done
   286 14E2 60				rts 
   287 					
   288 				;-----------------
   289
   290 14E3			calculate_time 
   291 14E3 AD C3 14			lda is_playing_flag 
   292 14E6 D0 27			bne notimetolose	; not playing -> no time counter increment  
   293 14E8 CE F4 14			dec v_frame		; decrement the frame counter
   294 14EB D0 22			bne notimetolose	; not 0 -> a second did not yet pass
   295 14ED A9 00			lda #0
   296 = 14EE			framecount equ *-1		; 50 or 60, defined by the region initialisation
   297 14EF 8D F4 14			sta v_frame		; reset the frame counter
   298 14F2 D0 01			bne addasecond		; unconditional
   299 14F4 EA				nop
   300 = 14F4			v_frame equ *-1			; the NOP instruction is overwritten by the frame counter	
   301 14F5			addasecond
   302 14F5 F8				sed			; set decimal flag first
   303 14F6 A9 00			lda #0
   304 = 14F7			v_second equ *-1
   305 14F8 18				clc			; clear the carry flag first, the keyboard code could mess with this part now...
   306 14F9 69 01			adc #1			; carry flag is clear, add 1 directly
   307 14FB 8D F7 14			sta v_second
   308 14FE C9 60			cmp #$60		; 60 seconds, must be a HEX value!
   309 1500 D0 0C			bne cleardecimal 	; if not equal, no minute increment
   310 1502 A0 00			ldy #0			; will be used to clear values quicker
   311 1504			addaminute
   312 1504 A9 00			lda #0
   313 = 1505			v_minute equ *-1
   314 1506 69 00			adc #0			; carry flag is set above, adding 0 will add 1 instead
   315 1508 8D 05 15			sta v_minute
   316 150B 8C F7 14			sty v_second		; reset the second counter
   317 150E			cleardecimal 
   318 150E D8				cld			; clear decimal flag 
   319 150F			notimetolose
   320 150F 60				rts
   321 					
   322 				;-----------------
   323
   324 1510			reset_timer
   325 1510 A9 00			lda #0
   326 1512 8D F7 14			sta v_second		; reset the seconds counter
   327 1515 8D 05 15			sta v_minute		; reset the minutes counter
   328 1518 AD EE 14			lda framecount		; number of frames defined at initialisation  
   329 151B 8D F4 14			sta v_frame		; reset the frames counter 
   330 151E 60				rts
   331 					
   332 				;-----------------
   333
   334 				; Check the Volume Only bit in CH1, if set but below the $Fx range, it's used, else, it's proper Volume Only output
   335
   336 151F			CheckForTwoToneBit
   337 151F A0 03			ldy #3			; default SKCTL register state
   338 1521 AE 46 15			ldx POKC0		; AUDC1
   339 1524 E0 F0			cpx #$F0		; is the tune expected to run with Proper Volume Only output?
   340 1526 B0 0D			bcs NoTwoTone		; if equal or above, this is not used for Two-Tone, don't set it
   341 1528 8A				txa
   342 1529 29 10			and #$10		; test the Volume Only bit
   343 152B F0 08			beq NoTwoTone		; if it is not set, there is no Two-Tone Filter active
   344 152D 8A				txa
   345 152E 49 10			eor #$10		; reverse the Volume Only bit
   346 1530 8D 46 15			sta POKC0		; overwrite the AUDC
   347 1533 A0 8B			ldy #$8B		; set the Two-Tone Filter output
   348 1535			NoTwoTone
   349 1535 8C 4E 15			sty POKSKC0		; overwrite the buffered SKCTL byte with the new value
   350 1538 60				rts
   351
   352 				;-----------------
   353
   354 				;* Swap POKEY buffers for Stereo Playback, this is a really dumb hack but that saves the troubles of touching the unrolled LZSS driver's code
   355
   356 1539			SwapBuffer
   357 1539 A0 09			ldy #9
   358 153B			SwapBufferLoop
   359 153B B9 45 15			lda SDWPOK0,y
   360 153E 99 4F 15			sta SDWPOK1,y
   361 1541 88				dey
   362 1542 10 F7			bpl SwapBufferLoop
   363 1544 60				rts
   364
   365 				;-----------------
   366
   367 				;* Left POKEY
   368
   369 1545			SDWPOK0 
   370 1545 00			POKF0	dta $00
   371 1546 00			POKC0	dta $00
   372 1547 00			POKF1	dta $00
   373 1548 00			POKC1	dta $00
   374 1549 00			POKF2	dta $00
   375 154A 00			POKC2	dta $00
   376 154B 00			POKF3	dta $00
   377 154C 00			POKC3	dta $00
   378 154D 00			POKCTL0	dta $00
   379 154E 03			POKSKC0	dta $03	
   380
   381 				;* Right POKEY
   382
   383 154F			SDWPOK1	
   384 154F 00			POKF4	dta $00
   385 1550 00			POKC4	dta $00
   386 1551 00			POKF5	dta $00
   387 1552 00			POKC5	dta $00
   388 1553 00			POKF6	dta $00
   389 1554 00			POKC6	dta $00
   390 1555 00			POKF7	dta $00
   391 1556 00			POKC7	dta $00
   392 1557 00			POKCTL1	dta $00
   393 1558 03			POKSKC1	dta $03
   394
   395 				;-----------------
   396
   397 				;//---------------------------------------------------------------------------------------------
   398
   399 				;* To be able to use all the subroutines, include lzssp.asm in the project that may use the driver, 
   400 				;* Alternatively, include the code directly below  
   401 				;* The ORG addresses could be changed or even omitted if necessary! 
   402 					
   403 				;	org SOUNDTEST			
   404 1559				icl "DUMB_Soundtest.asm"	; example program by VinsCool 
Source: DUMB_Soundtest.asm
     1 				;* --- Dumb Unless Made Better ---
     2 				;*
     3 				;* DUMB Soundtest-LZSS v0.1
     4 				;*
     5 				;* An attempt for a flexible LZSS music driver for the Atari 8-bit
     6 				;* By VinsCool, being worked on from July 27th to July 30th 2022 
     7 				;*
     8 				;* To build: 'mads lzssp.asm -l:ASSEMBLED/build.lst -o:ASSEMBLED/build.xex' 
     9
    10 				;-----------------
    11
    12 				;//---------------------------------------------------------------------------------------------
    13
    14 				; song speed xVBI
    15
    16 = 0001			SongSpeed	equ 1		; 1 => 50/60hz, 2 => 100/120hz, etc
    17
    18 				; playback speed will be adjusted accordingly in the other region
    19
    20 = 0000			REGIONPLAYBACK	equ 0		; 0 => PAL, 1 => NTSC
    21
    22 				; Stereo is now supported with the LZSS driver!
    23
    24 = 0001			STEREO		equ 1		; 0 => MONO, 255 => STEREO, 1 => DUAL MONO
    25
    26 = 00FE			DISPLAY 	equ $FE		; Display List indirect memory address
    27
    28 				;* Subtune index number is offset by 1, meaning the subtune 0 would be subtune 1 visually
    29
    30 = 0001			TUNE_NUM	equ (SongIndexEnd-SongIndex)/4
    31
    32 				;* Sound effects index number will be displayed the same way for simplicity
    33
    34 = 000A			SFX_NUM		equ 10		; Bunny Hop SFX by PG 
    35
    36 = 0008			VLINE		equ 8		; 16 is the default according to Raster's example player 
    37 = 0069			RASTERBAR	equ $69		; $69 is a nice purpleish hue 
    38
    39 				;-----------------
    40
    41 				;//---------------------------------------------------------------------------------------------
    42
    43 				;* Initialisation, then loop infinitely unless the program is told otherwise 
    44
    45 1559			start       
    46 1559 A2 00			ldx #0			; disable playfield and the black colour value
    47 155B 8E 2F 02			stx SDMCTL		; write to Shadow Direct Memory Access Control address
    48 155E 20 5B 16			jsr wait_vblank		; wait for vblank before continuing
    49 1561 8E C8 02			stx COLOR4		; Shadow COLBK (background colour), black
    50 1564 8E C6 02			stx COLOR2		; Shadow COLPF2 (playfield colour 2), black
    51 1567 A9 14 8D 30 02 A9 + 	mwa #dlist SDLSTL	; Start Address of the Display List
    52 1571 8E 83 13			stx SongIdx 		; default tune index number
    53 1574 8E 3F 18			stx SfxIdx 		; default sfx index number
    54 1577 20 EA 18			jsr set_index_count 	; print number of tunes and sfx indexed in memory
    55 157A 20 AE 18			jsr set_tune_name	; print the tune name 
    56 157D 20 C5 18			jsr set_sfx_name	; print the sfx name
    57 1580 20 F0 16			jsr detect_region
    58 1583 20 26 14			jsr stop_toggle
    59 1586 A2 22			ldx #$22		; DMA enable, normal playfield
    60 1588 8E 2F 02			stx SDMCTL		; write to Shadow Direct Memory Access Control address
    61 158B A2 32			ldx #50	
    62 158D			wait_init   
    63 158D 20 5B 16			jsr wait_vblank		; wait for vblank => 50 frames
    64 1590 CA				dex			; decrement index x
    65 1591 D0 FA			bne wait_init		; repeat until x = 0, total wait time is ~2 seconds
    66 1593			init_done
    67 1593 78				sei			; Set Interrupt Disable Status
    68 1594 AD 22 02 8D 12 1E + 	mwa VVBLKI oldvbi       ; vbi address backup
    69 15A0 A9 29 8D 22 02 A9 + 	mwa #vbi VVBLKI		; write our own vbi address to it 
    70 15AA A9 40 8D 0E D4		mva #$40 NMIEN		; enable vbi interrupts
    71 15AF			wait_sync
    72 15AF AD 0B D4			lda VCOUNT		; current scanline 
    73 15B2 C9 08			cmp #VLINE		; will stabilise the timing if equal
    74 15B4 90 F9			bcc wait_sync		; nope, repeat 
    75 15B6 20 C2 14			jsr play_pause_toggle	; now is the good time to toggle play
    76 					
    77 				;-----------------
    78
    79 				;//---------------------------------------------------------------------------------------------
    80
    81 				;* main loop, code runs from here ad infinitum after initialisation
    82
    83 15B9			loop
    84 15B9 A0 69			ldy #RASTERBAR			; custom rasterbar colour
    85 = 15BA			rasterbar_colour equ *-1
    86 15BB			acpapx1
    87 15BB AD D4 15			lda spap
    88 15BE A2 00			ldx #0
    89 = 15BF			cku	equ *-1
    90 15C0 D0 1B			bne keepup
    91 15C2 AD 0B D4			lda VCOUNT			; vertical line counter synchro
    92 15C5 AA				tax
    93 15C6 38 E9 08			sub #VLINE
    94 = 15C8			lastpap	equ *-1
    95 15C9 B0 02 69 FF			scs:adc #$ff
    96 = 15CC			ppap	equ *-1
    97 15CD 8D D7 15			sta dpap
    98 15D0 8E C8 15			stx lastpap
    99 15D3 A9 00			lda #0
   100 = 15D4			spap	equ *-1
   101 15D5 38 E9 00			sub #0
   102 = 15D7			dpap	equ *-1
   103 15D8 8D D4 15			sta spap
   104 15DB B0 DE			bcs acpapx1
   105 15DD			keepup
   106 15DD 69 FF			adc #$ff
   107 = 15DE			acpapx2	equ *-1
   108 15DF 8D D4 15			sta spap
   109 15E2 A2 00			ldx #0
   110 15E4 B0 01 E8			scs:inx
   111 15E7 8E BF 15			stx cku
   112 15EA			check_play_flag
   113 15EA AD C3 14			lda is_playing_flag 		; 0 -> is playing, else it is either stopped or paused 
   114 15ED D0 30			bne do_sfx			; in this case, nothing will happen until it is changed back to 0 
   115 15EF 8C 1A D0			sty COLBK			; background colour 
   116 15F2			do_play
   117 15F2 20 44 14			jsr setpokeyfull		; update the POKEY registers first, for both the SFX and LZSS music driver 
   118 15F5 20 C2 11			jsr LZSSPlayFrame		; Play 1 LZSS frame
   119 15F8 20 3A 13			jsr LZSSUpdatePokeyRegisters	; buffer to let setpokeyfast match the RMT timing 
   120 15FB 20 1F 15			jsr CheckForTwoToneBit		; if set, the Two-Tone Filter will be enabled 
   121 15FE AD 81 14			lda is_stereo_flag		; FF == Stereo
   122 1601 F0 0C			beq finish_loop_code		; 0 == Mono
   123 				;	bpl only_swap_buffer		; 1 == Dual Mono, unfinished 
   124 1603			do_double_buffer			
   125 1603 20 39 15			jsr SwapBuffer			; dumb ass Stereo hack but hey if it works who the fuck cares
   126 1606 20 C2 11			jsr LZSSPlayFrame		; Play 1 LZSS frame (again) 
   127 1609 20 3A 13			jsr LZSSUpdatePokeyRegisters	; buffer to let setpokeyfast match the RMT timing (again) 
   128 160C 20 1F 15			jsr CheckForTwoToneBit		; if set, the Two-Tone Filter will be enabled (again) 
   129 160F			finish_loop_code
   130 160F 20 DD 13			jsr fade_volume_loop		; run the fadeing out code from here until it's finished
   131 1612 AD C3 14			lda is_playing_flag		; was the player paused/stopped after fadeing out?
   132 1615 D0 08			bne do_sfx			; if not equal, it was most likely stopped, and so there is nothing else to do here 
   133 1617			do_play_next
   134 1617 20 2B 13			jsr LZSSCheckEndOfSong		; is the current LZSS index done playing?
   135 161A D0 03			bne do_sfx			; if not, go back to the loop and wait until the next call
   136 161C 20 A2 13			jsr SetNewSongPtrs		; update the subtune index for the next one in adjacent memory 
   137 161F			do_sfx
   138 161F 20 5C 18			jsr play_sfx			; process the SFX data, if an index is queued and ready to play for this frame 
   139 1622 A0 00			ldy #$00			; black colour value
   140 1624 8C 1A D0			sty COLBK			; background colour
   141 1627 F0 90			beq loop			; unconditional
   142
   143 				;----------------- 
   144
   145 				;//---------------------------------------------------------------------------------------------
   146
   147 				;* VBI loop, run through all the code that is needed, then return with a RTI 
   148
   149 1629			vbi 
   150 				;	sta WSYNC
   151 1629			check_key_pressed 
   152 1629 AE 0F D2			ldx SKSTAT		; Serial Port Status
   153 162C 8A				txa
   154 162D 29 04			and #$04		; last key still pressed?
   155 162F D0 16			bne continue		; if not, skip ahead, no input to check 
   156 1631 AD 09 D2			lda KBCODE		; Keyboard Code  
   157 1634 29 3F			and #$3F		; clear the SHIFT and CTRL bits out of the key identifier for the next part
   158 1636 A8				tay
   159 1637 8A				txa
   160 1638 29 08			and #$08		; SHIFT key being held?
   161 163A F0 04			beq skip_held_key_check	; if yes, skip the held key flag check, else, verify if the last key is still being held
   162 163C			check_keys_always
   163 163C A9 00			lda #0 			; was the last key pressed also held for at least 1 frame? This is a measure added to prevent accidental input spamming
   164 = 163D				held_key_flag equ *-1
   165 163E 30 0C			bmi continue_b		; the held key flag was set if the value is negative! skip ahead immediately in this case 
   166 1640			skip_held_key_check
   167 1640 20 07 19			jsr check_keys		; each 'menu' entry will process its action, and return with RTS, the 'held key flag' must then be set!
   168 1643 A2 FF			ldx #$FF
   169 1645 30 02			bmi continue_a		; skip ahead and set the held key flag! 
   170 1647			continue			; do everything else during VBI after the keyboard checks 
   171 1647 A2 00			ldx #0			; reset the held key flag! 
   172 1649			continue_a 			; a new held key flag is set when jumped directly here
   173 1649 8E 3D 16			stx held_key_flag 
   174 164C			continue_b 			; a key was detected as held when jumped directly here 
   175 164C 20 AA 17			jsr check_joystick	; check the inputs for tunes and sfx index 
   176 164F 20 E3 14			jsr calculate_time 	; update the timer, this one is actually necessary, so even with DMA off, it will be executed
   177 1652 20 17 17			jsr print_player_infos	; print most of the stuff on screen using printhex or printinfo in bulk 
   178 1655			continue_c
   179 				;	sta WSYNC
   180 1655			return_from_vbi	
   181 1655 68				pla			;* since we're in our own vbi routine, pulling all values manually is required! 
   182 1656 A8				tay
   183 1657 68				pla
   184 1658 AA				tax
   185 1659 68				pla
   186 165A 40				rti			; return from interrupt, this ends the VBI time, whenever it actually is "finished" 
   187
   188 				;-----------------
   189
   190 				;//---------------------------------------------------------------------------------------------
   191
   192 				;* Everything below this point is either stand alone subroutines that can be called at any time, and the display list 
   193
   194 				;//---------------------------------------------------------------------------------------------
   195
   196 				;* Wait for vblank subroutine
   197
   198 165B			wait_vblank 
   199 165B A5 14			lda RTCLOK+2		; load the real time frame counter to accumulator
   200 165D			wait        
   201 165D C5 14			cmp RTCLOK+2		; compare to itself
   202 165F F0 FC			beq wait		; equal means it vblank hasn't began
   203 1661 60				rts
   204
   205 				;-----------------
   206
   207 				; Print text from data tables, useful for many things 
   208
   209 1662			printinfo 
   210 1662 8C 6F 16			sty charbuffer
   211 1665 A0 00			ldy #0
   212 1667			do_printinfo
   213 1667 BD FF FF		        lda $ffff,x
   214 = 1668			infosrc equ *-2
   215 166A 91 FE			sta (DISPLAY),y
   216 166C E8				inx
   217 166D C8				iny 
   218 166E C0 00			cpy #0
   219 = 166F			charbuffer equ *-1
   220 1670 D0 F5			bne do_printinfo 
   221 1672 60				rts
   222
   223 				;-----------------
   224
   225 				; Print hex characters for several things, useful for displaying all sort of debugging infos
   226 					
   227 1673			printhex
   228 1673 A0 00			ldy #0
   229 1675			printhex_direct     ; workaround to allow being addressed with y in different subroutines
   230 1675 48				pha
   231 1676 4A 4A 4A 4A			:4 lsr @
   232 					;beq ph1    ; comment out if you want to hide the leftmost zeroes
   233 167A AA				tax
   234 167B BD 8B 16			lda hexchars,x
   235 167E			ph1	
   236 167E 91 FE C8		        sta (DISPLAY),y+
   237 1681 68				pla
   238 1682 29 0F			and #$f
   239 1684 AA				tax
   240 1685 BD 8B 16 91 FE		mva hexchars,x (DISPLAY),y
   241 168A 60				rts
   242 168B			hexchars 
   243 168B 10 11 12 13 14 15 +         dta d"0123456789ABCDEF"
   244
   245 				;-----------------
   246
   247 				;* Convert Hexadecimal numbers to Decimal without lookup tables 
   248 				;* Based on the routine created by Andrew Jacobs, 28-Feb-2004 
   249 				;* http://6502.org/source/integers/hex2dec-more.htm 
   250
   251 169B			hex2dec_convert
   252 169B C9 0A			cmp #10			; below 10 -> 0 to 9 inclusive will display like expected, skip the conversion
   253 169D 90 2E			bcc hex2dec_convert_b
   254 169F C9 64			cmp #100		; process with numbers below 99, else skip the conversion entirely 
   255 16A1 B0 2A			bcs hex2dec_convert_b  
   256 16A3			hex2dec_convert_a
   257 16A3 8D D0 16			sta hex_num		; temporary 
   258 16A6 F8				sed
   259 16A7 A9 00			lda #0			; initialise the conversion values
   260 16A9 8D CE 16			sta dec_num
   261 16AC 8D CF 16			sta dec_num+1
   262 16AF A2 07			ldx #7			; 8 bits to process 
   263 16B1			hex2dec_loop
   264 16B1 0E D0 16			asl hex_num 
   265 16B4 AD CE 16			lda dec_num		; And add into result
   266 16B7 6D CE 16			adc dec_num
   267 16BA 8D CE 16			sta dec_num
   268 16BD AD CF 16			lda dec_num+1		; propagating any carry
   269 16C0 6D CF 16			adc dec_num+1
   270 16C3 8D CF 16			sta dec_num+1
   271 16C6 CA				dex			; And repeat for next bit
   272 16C7 10 E8			bpl hex2dec_loop
   273 16C9 D8				cld			; Back to binary
   274 16CA AD CE 16			lda dec_num 
   275 16CD			hex2dec_convert_b
   276 16CD 60				rts			; the value will be returned in the accumulator 
   277
   278 16CE 00 00		dec_num dta $00,$00
   279 16D0 00			hex_num dta $00
   280 					
   281 				;-----------------
   282
   283 				; Stop and quit when execution jumps here
   284
   285 16D1			stop_and_exit
   286 16D1 20 37 14			jsr stop_pause_reset 
   287 16D4 AD 12 1E 8D 22 02 + 	mwa oldvbi VVBLKI	; restore the old vbi address
   288 16E0 A2 00			ldx #$00		; disable playfield 
   289 16E2 8E 2F 02			stx SDMCTL		; write to Direct Memory Access (DMA) Control register
   290 16E5 CA				dex			; underflow to #$FF
   291 16E6 8E FC 02			stx CH			; write to the CH register, #$FF means no key pressed
   292 16E9 58				cli			; this may be why it seems to crash on hardware... I forgot to clear the interrupt bit!
   293 16EA 20 5B 16			jsr wait_vblank		; wait for vblank before continuing
   294 16ED 6C 0A 00			jmp (DOSVEC)		; return to DOS, or Self Test by default
   295
   296 				;----------------- 
   297
   298 				;* Detect the machine region subroutine
   299
   300 16F0			detect_region	
   301 16F0 AD 0B D4			lda VCOUNT
   302 16F3 F0 03			beq check_region	; vcount = 0, go to check_region and compare values
   303 16F5 AA				tax			; backup the value in index y
   304 16F6 D0 F8			bne detect_region 	; repeat
   305 16F8			check_region
   306 				;	stx region_byte		; will define the region text to print later
   307 16F8 A0 01			ldy #SongSpeed		; defined speed value, which may be overwritten by RMT as well
   308 = 16F9			PLAYER_SONG_SPEED equ *-1
   309 				;	sty instrspeed		; will be re-used later as well for the xVBI speed value printed
   310 					IFT REGIONPLAYBACK==0	; if the player region defined for PAL...
   311 = 16FA			PLAYER_REGION_INIT equ *	
   312 16FA B9 D1 1D			lda tabppPAL-1,y
   313 16FD 8D DE 15			sta acpapx2		; lines between each play
   314 1700 E0 9B			cpx #$9B		; compare X to 155
   315 1702 30 07			bmi set_ntsc		; negative result means the machine runs at 60hz		
   316 1704 B9 E1 1D			lda tabppPALfix-1,y
   317 1707 A0 32			ldy #50
   318 1709 D0 05			bne region_done 
   319 170B			set_ntsc
   320 170B B9 01 1E			lda tabppNTSCfix-1,y	; if NTSC is detected, adjust the speed from PAL to NTSC
   321 170E A0 3C			ldy #60
   322 					ELI REGIONPLAYBACK==1	; else, if the player region defined for NTSC...
   323 				PLAYER_REGION_INIT equ *	
   324 					lda tabppNTSC-1,y
   325 					sta acpapx2		; lines between each play
   326 					cpx #$9B		; compare X to 155	
   327 					bpl set_pal		; positive result means the machine runs at 50hz 
   328 					lda tabppNTSCfix-1,y
   329 					ldy #60
   330 					bne region_done 
   331 				set_pal
   332 					lda tabppPALfix-1,y	; if PAL is detected, adjust the speed from NTSC to PAL
   333 					ldy #50
   334 					EIF			; endif 
   335 1710			region_done
   336 1710 8D CC 15			sta ppap		; stability fix for screen synchronisation 
   337 1713 8C EE 14			sty framecount
   338 1716 60				rts
   339
   340 				;-----------------
   341
   342 				;* Print most infos on screen
   343 					
   344 1717			print_player_infos
   345 1717 A9 92 85 FE A9 1C + 	mwa #line_0 DISPLAY 	; get the right screen position
   346 171F			print_minutes
   347 171F AD 05 15			lda v_minute
   348 1722 A0 08			ldy #8
   349 1724 20 75 16			jsr printhex_direct
   350 1727			print_seconds
   351 1727 AE F7 14			ldx v_second
   352 172A 8A				txa
   353 172B A0 0A			ldy #10
   354 172D 29 01			and #1
   355 172F F0 04			beq no_blink 
   356 1731 A9 00			lda #0
   357 1733 F0 02			beq blink
   358 1735			no_blink 
   359 1735 A9 1A			lda #":" 
   360 1737			blink
   361 1737 91 FE			sta (DISPLAY),y 
   362 1739 C8				iny 
   363 173A			done_blink
   364 173A 8A				txa
   365 173B 20 75 16			jsr printhex_direct
   366 173E			print_order	
   367 173E A5 01			lda ZPLZS.SongPtr+1
   368 1740 A0 22			ldy #34
   369 1742 20 75 16			jsr printhex_direct
   370 1745			print_row
   371 1745 A5 00			lda ZPLZS.SongPtr 
   372 1747 A0 24			ldy #36
   373 1749 20 75 16			jsr printhex_direct 
   374 174C			print_tune
   375 174C A9 01			lda #1
   376 = 174D			tune_index equ *-1
   377 174E 20 9B 16			jsr hex2dec_convert 
   378 1751 A0 7D			ldy #125
   379 1753 20 75 16			jsr printhex_direct 
   380 1756			print_sfx
   381 1756 A9 01			lda #1
   382 = 1757			sfx_index equ *-1
   383 1758 20 9B 16			jsr hex2dec_convert 
   384 175B A0 A5			ldy #165
   385 175D 20 75 16			jsr printhex_direct 
   386 1760			print_pointers
   387 1760 A0 37			ldy #55
   388 1762 AD 01 11			lda LZS.SongStartPtr+1
   389 1765 20 75 16			jsr printhex_direct
   390 1768 C8				iny
   391 1769 AD 00 11			lda LZS.SongStartPtr
   392 176C 20 75 16			jsr printhex_direct	
   393 176F A0 47			ldy #71
   394 1771 AD 03 11			lda LZS.SongEndPtr+1
   395 1774 20 75 16			jsr printhex_direct
   396 1777 C8				iny
   397 1778 AD 02 11			lda LZS.SongEndPtr
   398 177B 20 75 16			jsr printhex_direct
   399 177E			print_flags
   400 177E A0 56			ldy #86
   401 1780 AD 07 11			lda LZS.Initialized
   402 1783 20 75 16			jsr printhex_direct
   403 1786 A0 5E			ldy #94
   404 1788 AD C3 14			lda is_playing_flag
   405 178B 20 75 16			jsr printhex_direct
   406 178E A0 65			ldy #101
   407 1790 AD A3 13			lda is_looping 
   408 1793 38 E9 01			sub #1
   409 1796 20 75 16			jsr printhex_direct
   410 1799 A0 6C			ldy #108
   411 179B AD B9 13			lda loop_count 
   412 179E 20 75 16			jsr printhex_direct
   413 17A1 A0 74			ldy #116
   414 17A3 AD DE 13			lda is_fadeing_out
   415 17A6 20 75 16			jsr printhex_direct
   416 17A9 60				rts
   417 					
   418 				;-----------------
   419
   420 				;* Joystick input handler, using PORTA 
   421
   422 17AA			check_joystick
   423 17AA AE 00 D3			ldx PORTA
   424 17AD 8A				txa
   425 17AE 29 0F			and #%00001111
   426 17B0 C9 0F			cmp #%00001111			; neutral
   427 17B2 D0 1B			bne check_joystick_being_held
   428 17B4 A9 00			lda #0
   429 17B6 8D D0 17			sta held_joystick_flag		; reset held joystick flag
   430 17B9 AD 10 D0			lda TRIG0			; 'Fire' button
   431 17BC F0 07			beq check_fire_being_held	; button pressed if 0
   432 17BE A9 00			lda #0
   433 17C0 8D C6 17			sta held_fire_flag		; reset held button flag
   434 17C3 F0 0E			beq check_joystick_done
   435 17C5			check_fire_being_held
   436 17C5 A9 00			lda #0
   437 = 17C6			held_fire_flag equ *-1
   438 17C7 30 0A			bmi check_joystick_done		; fire is already being held, ignore the input
   439 17C9 CE C6 17			dec held_fire_flag		; held button flag set again
   440 17CC 4C 3E 18			jmp set_sfx_to_play		; end with a RTS!
   441 17CF			check_joystick_being_held
   442 17CF A9 00			lda #0
   443 = 17D0			held_joystick_flag equ *-1
   444 17D1 10 01			bpl check_joystick_up_down	; process the check, otherwise, a direction is already being held, ignore the input 	
   445 17D3			check_joystick_done
   446 17D3 60				rts
   447
   448 				;-----------------
   449
   450 				;* Up and Down bits
   451
   452 17D4			check_joystick_up_down
   453 17D4 AC 57 17			ldy sfx_index	
   454 17D7 8A				txa
   455 17D8 29 03			and #%00000011
   456 17DA C9 03			cmp #%00000011
   457 17DC F0 2A			beq check_joystick_left_right
   458 17DE CE D0 17			dec held_joystick_flag
   459
   460 				;-----------------
   461
   462 				;* Down
   463
   464 17E1			do_joystick_down
   465 17E1 C9 01			cmp #%00000001 
   466 17E3 D0 0B			bne do_joystick_up
   467 17E5 88				dey
   468 17E6 F0 04			beq sfx_index_wrap
   469 17E8 30 02			bmi sfx_index_wrap
   470 17EA D0 11			bne update_sfx_index
   471 17EC			sfx_index_wrap
   472 17EC A0 0A			ldy #SFX_NUM
   473 17EE 10 0D			bpl update_sfx_index
   474
   475 				;-----------------
   476
   477 				;* Up
   478
   479 17F0			do_joystick_up	
   480 17F0 C9 02			cmp #%00000010 
   481 17F2 D0 09			bne update_sfx_index
   482 17F4 C8				iny
   483 17F5 C0 0A			cpy #SFX_NUM
   484 17F7 90 04			bcc update_sfx_index
   485 17F9 F0 02			beq update_sfx_index
   486 17FB A0 01			ldy #1
   487 17FD			update_sfx_index
   488 17FD 8C 57 17			sty sfx_index 
   489 1800 20 9E 18			jsr check_sfx_index 
   490 1803 A9 01			lda #1				; play sfx: menu movement 
   491 1805 4C 40 18			jmp set_sfx_to_play_immediate	; end with a RTS! 
   492
   493 				;-----------------
   494
   495 				;* Left and Right bits
   496
   497 1808			check_joystick_left_right
   498 1808 AC 4D 17			ldy tune_index
   499 180B 8A				txa
   500 180C 29 0C			and #%00001100
   501 180E C9 0C			cmp #%00001100
   502 1810 F0 C1			beq check_joystick_done
   503 1812 CE D0 17			dec held_joystick_flag 
   504
   505 				;-----------------
   506
   507 				;* Left
   508
   509 1815			do_joystick_left	
   510 1815 C9 08			cmp #%00001000 
   511 1817 D0 0C			bne do_joystick_right
   512 1819 88				dey
   513 181A F0 04			beq tune_index_wrap
   514 181C 30 02			bmi tune_index_wrap
   515 181E D0 13			bne update_tune_index
   516 1820			tune_index_wrap
   517 1820 AC F3 18			ldy SongTotal
   518 1823 10 0E			bpl update_tune_index
   519
   520 				;-----------------
   521
   522 				;* Right 
   523
   524 1825			do_joystick_right	
   525 1825 C9 04			cmp #%00000100 
   526 1827 D0 0A			bne update_tune_index 
   527 1829 C8				iny
   528 182A CC F3 18			cpy SongTotal
   529 182D 90 04			bcc update_tune_index
   530 182F F0 02			beq update_tune_index
   531 1831 A0 01			ldy #1
   532 1833			update_tune_index
   533 1833 8C 4D 17			sty tune_index
   534 1836 20 88 18			jsr check_tune_index 
   535 1839 A9 01			lda #1				; play sfx: menu movement 
   536 183B 4C 40 18			jmp set_sfx_to_play_immediate	; end with a RTS!  
   537
   538 				;-----------------
   539
   540 				;* Initialise the SFX to play in memory once the joystick button is pressed, using the SFX index number
   541
   542 183E			set_sfx_to_play
   543 183E A9 00			lda #0
   544 = 183F			SfxIdx equ *-1
   545 1840			set_sfx_to_play_immediate
   546 1840 0A				asl @
   547 1841 AA				tax
   548 1842 BD 1A 1B			lda sfx_data,x
   549 1845 8D 75 18			sta sfx_src
   550 1848 BD 1B 1B			lda sfx_data+1,x
   551 184B 8D 76 18			sta sfx_src+1
   552 184E EE 5D 18			inc is_playing_sfx 
   553 1851 A9 03			lda #3 
   554 1853 8D 6D 18			sta sfx_channel
   555 1856 A9 00			lda #0
   556 1858 8D 66 18			sta sfx_offset
   557 185B 60				rts
   558
   559 				;-----------------
   560
   561 				;* Play the SFX currently set in memory, one frame every VBI
   562
   563 185C			play_sfx
   564 185C A9 FF			lda #$FF		; #$00 -> Play SFX until it's ended, #$FF -> SFX has finished playing and is stopped
   565 = 185D			is_playing_sfx equ *-1
   566 185E 30 27			bmi play_sfx_done
   567 1860 A9 02			lda #2			; 2 frames
   568 1862 8D 5D 18			sta is_playing_sfx
   569 1865 A9 00			lda #0
   570 = 1866			sfx_offset equ *-1
   571 1867 0A				asl @
   572 1868 AA				tax
   573 1869 EE 66 18			inc sfx_offset
   574 186C A9 00			lda #0
   575 = 186D			sfx_channel equ *-1
   576 186E 0A				asl @
   577 186F A8				tay
   578 1870 10 02			bpl begin_play_sfx
   579 1872			play_sfx_loop
   580 1872 E8				inx
   581 1873 C8				iny
   582 1874			begin_play_sfx
   583 1874 BD FF FF		        lda $ffff,x
   584 = 1875			sfx_src equ *-2
   585 1877 99 45 15			sta SDWPOK0,y
   586 187A CE 5D 18			dec is_playing_sfx
   587 187D D0 F3			bne play_sfx_loop
   588 187F B9 45 15			lda SDWPOK0,y
   589 1882 D0 03			bne play_sfx_done
   590 1884 CE 5D 18			dec is_playing_sfx
   591 1887			play_sfx_done
   592 1887 60				rts
   593
   594 				;-----------------
   595
   596 				;* Compare the tune index number to the one being displayed
   597 				;* If they don't match, a new tune will play!
   598
   599 1888			check_tune_index 
   600 1888 AE 4D 17			ldx tune_index
   601 188B CA				dex				; offset by 1, since the first entry is 0
   602 188C EC 83 13			cpx SongIdx
   603 188F D0 01			bne check_tune_index_a 
   604 1891			check_tune_index_done	
   605 1891 60				rts				; if they are the same, there is nothing else to do here 
   606 1892			check_tune_index_a	
   607 1892 8E 83 13			stx SongIdx
   608 1895 20 B0 18			jsr update_tune_name 
   609 1898 20 77 13			jsr SetNewSongPtrsFull 
   610 189B 4C 10 15			jmp reset_timer 		; end with a RTS! 
   611
   612 				;-----------------
   613
   614 				;* Compare the sfx index number to the one being displayed
   615 				;* If they don't match, a new sfx will play!
   616
   617 189E			check_sfx_index 
   618 189E AE 57 17			ldx sfx_index
   619 18A1 CA				dex				; offset by 1, since the first entry is 0
   620 18A2 EC 3F 18			cpx SfxIdx 
   621 18A5 D0 01			bne check_sfx_index_a 
   622 18A7			check_sfx_index_done	
   623 18A7 60				rts				; if they are the same, there is nothing else to do here 
   624 18A8			check_sfx_index_a
   625 18A8 8E 3F 18			stx SfxIdx
   626 18AB 4C C7 18			jmp update_sfx_name 		; end with a RTS! 
   627
   628 				;-----------------
   629
   630 				;* Update the song name displayed on screen based on the index number
   631
   632 18AE			set_tune_name
   633 18AE A2 00			ldx #0				; default index number, else, use the value from X directly
   634 18B0			update_tune_name
   635 18B0 A9 16 85 FE A9 1D + 	mwa #line_3+12 DISPLAY		; set the screen coordinates for the song name displayed on screen
   636 18B8 A9 9A 8D 68 16 A9 + 	mwa #song_name infosrc		; set the memory address for the text data 
   637 18C2 4C D9 18			jmp update_both_name		; end with a RTS over there! 
   638
   639 				;-----------------
   640
   641 				;* Update the sfx name displayed on screen based on the index number
   642
   643 18C5			set_sfx_name
   644 18C5 A2 00			ldx #0				; default index number, else, use the value from X directly
   645 18C7			update_sfx_name
   646 18C7 A9 3E 85 FE A9 1D + 	mwa #line_4+12 DISPLAY		; set the screen coordinates for the sfx name displayed on screen
   647 18CF A9 DA 8D 68 16 A9 + 	mwa #sfx_name infosrc		; set the memory address for the text data 
   648
   649 				;-----------------
   650
   651 				;* Both the song name and sfx name will use the same code for drawing text on screen after addresses initialisation 
   652
   653 18D9			update_both_name 
   654 18D9 8A				txa
   655 18DA 0A 0A 0A 0A 0A		:5 asl @
   656 18DF 90 03 EE 69 16		scc:inc infosrc+1
   657 18E4 AA				tax 
   658 18E5 A0 1C			ldy #28				; 32 characters per index 
   659 18E7 4C 62 16			jmp printinfo			; end with a RTS! 
   660
   661 				;-----------------
   662
   663 				;* Display the number of tunes and sfx indexed in memory, using the values defined at assembly time 
   664
   665 18EA			set_index_count
   666 18EA A9 92 85 FE A9 1C + 	mwa #line_0 DISPLAY 		; get the right screen position
   667 18F2 A9 01			lda #TUNE_NUM
   668 = 18F3				SongTotal equ *-1
   669 18F4 20 9B 16			jsr hex2dec_convert 
   670 18F7 A0 80			ldy #128 
   671 18F9 20 75 16			jsr printhex_direct
   672 18FC A9 0A			lda #SFX_NUM
   673 18FE 20 9B 16			jsr hex2dec_convert 
   674 1901 A0 A8			ldy #168
   675 1903 20 75 16			jsr printhex_direct
   676 1906 60				rts
   677
   678 				;-----------------
   679
   680 				;* check all keys that have a purpose here... 
   681 				;* this is the world's most cursed jumptable ever created!
   682 				;* regardless, this finally gets rid of all the spaghetti code I made previously!
   683
   684 1907			check_keys 
   685 1907 98				tya				; transfer to the accumulator to make a quick and dirty jump table
   686 1908 0A				asl @				; ASL only once, allowing a 2 bytes index, good enough for branching again immediately and unconditionally, 128 bytes needed sadly...
   687 1909 8D 0D 19			sta k_index+1			; branch will now match the value of Y
   688 190C D0 FE		k_index	bne * 
   689 190E 60 EA			rts:nop				; Y = 0 -> L key
   690 1910 60 EA			rts:nop
   691 1912 60 EA			rts:nop
   692 1914 60 EA			rts:nop
   693 1916 60 EA			rts:nop
   694 1918 60 EA			rts:nop
   695 191A 60 EA			rts:nop				; Y = 6 -> Atari 'Left' / '+' key
   696 191C 60 EA			rts:nop				; Y = 7 -> Atari 'Right' / '*' key 
   697 191E 90 71			bcc do_stop_toggle 		; Y = 8 -> 'O' key (not zero!!) 
   698 1920 60 EA			rts:nop
   699 1922 90 70			bcc do_play_pause_toggle	; Y = 10 -> 'P' key
   700 1924 60 EA			rts:nop
   701 1926 60 EA			rts:nop				; Y = 12 -> 'Enter' key
   702 1928 60 EA			rts:nop
   703 192A 60 EA			rts:nop
   704 192C 60 EA			rts:nop
   705 192E 60 EA			rts:nop
   706 1930 60 EA			rts:nop
   707 1932 60 EA			rts:nop				; Y = 18 -> 'C' key
   708 1934 60 EA			rts:nop
   709 1936 60 EA			rts:nop
   710 1938 60 EA			rts:nop
   711 193A 60 EA			rts:nop				; Y = 22 -> 'X' key
   712 193C 60 EA			rts:nop				; Y = 23 -> 'Z' key
   713 193E 60 EA			rts:nop				; Y = 24 -> '4' key
   714 1940 60 EA			rts:nop
   715 1942 60 EA			rts:nop				; Y = 26 -> '3' key
   716 1944 60 EA			rts:nop				; Y = 27 -> '6' key
   717 1946 90 46			bcc do_exit			; Y = 28 -> 'Escape' key
   718 1948 60 EA			rts:nop				; Y = 29 -> '5' key
   719 194A 60 EA			rts:nop				; Y = 30 -> '2' key
   720 194C 60 EA			rts:nop				; Y = 31 -> '1' key
   721 194E 60 EA			rts:nop
   722 1950 60 EA			rts:nop			 	; Y = 33 -> 'Spacebar' key
   723 1952 60 EA			rts:nop
   724 1954 60 EA			rts:nop
   725 1956 60 EA			rts:nop
   726 1958 60 EA			rts:nop
   727 195A 60 EA			rts:nop
   728 195C 60 EA			rts:nop
   729 195E 60 EA			rts:nop				; Y = 40 -> 'R' key
   730 1960 60 EA			rts:nop
   731 1962 60 EA			rts:nop
   732 1964 60 EA			rts:nop
   733 1966 60 EA			rts:nop
   734 1968 60 EA			rts:nop
   735 196A 60 EA			rts:nop				; Y = 46 -> 'W' key
   736 196C 60 EA			rts:nop
   737 196E 60 EA			rts:nop
   738 1970 60 EA			rts:nop
   739 1972 60 EA			rts:nop
   740 1974 60 EA			rts:nop				; Y = 51 -> '7' key
   741 1976 60 EA			rts:nop
   742 1978 60 EA			rts:nop				; Y = 53 -> '8' key
   743 197A 60 EA			rts:nop
   744 197C 60 EA			rts:nop
   745 197E 90 17			bcc do_trigger_fade_immediate	; Y = 56 -> 'F' key
   746 1980 60 EA			rts:nop				; Y = 57 -> 'H' key
   747 1982 60 EA			rts:nop				; Y = 58 -> 'D' key
   748 1984 60 EA			rts:nop
   749 1986 60 EA			rts:nop
   750 1988 60 EA			rts:nop
   751 198A 60 EA			rts:nop				; Y = 62 -> 'S' key
   752 198C 60 EA			rts:nop				; Y = 63 -> 'A' key
   753
   754 				;-----------------
   755
   756 				;* Jumptable from the branches above, long range in case things don't quite reach 
   757
   758 198E			do_exit
   759 198E 4C D1 16			jmp stop_and_exit		; stop and exit to DOS 
   760 					
   761 1991			do_stop_toggle
   762 1991 4C 26 14			jmp stop_toggle			; toggle stop flag
   763 					
   764 1994			do_play_pause_toggle	
   765 1994 4C C2 14			jmp play_pause_toggle		; toggle play/pause flag
   766
   767 1997			do_trigger_fade_immediate
   768 1997 4C D5 14			jmp trigger_fade_immediate	; immediately set the 'fadeout' flag then stop the player once finished
   769 					
   770 				;-----------------
   771
   772 				;//---------------------------------------------------------------------------------------------
   773
   774 				;* Song and SFX text data, 32 characters per entry, display 28 characters or less for best results
   775
   776 199A			song_name        
   777 199A 33 6B 65 74 63 68 + 	dta d"Sketch 44 Chunks, 5048 bytes    "
   778 19BA 33 6B 65 74 63 68 + 	dta d"Sketch 44 Full, 21970 bytes     "
   779
   780 19DA			sfx_name
   781 19DA 2D 65 6E 75 00 0D + 	dta d"Menu - Press                    " 
   782 19FA 2D 65 6E 75 00 0D + 	dta d"Menu - Movement                 " 
   783 1A1A 2D 65 6E 75 00 0D + 	dta d"Menu - Keyclick                 " 
   784 1A3A 2D 65 6E 75 00 0D + 	dta d"Menu - Code Rejected            " 
   785 1A5A 2D 65 6E 75 00 0D + 	dta d"Menu - Code Accepted            " 
   786 1A7A 27 61 6D 65 00 0D + 	dta d"Game - Select Unselect          " 
   787 1A9A 27 61 6D 65 00 0D + 	dta d"Game - Move Fox                 " 
   788 1ABA 27 61 6D 65 00 0D + 	dta d"Game - Move Bunny               " 
   789 1ADA 27 61 6D 65 00 0D + 	dta d"Game - In Hole                  " 
   790 1AFA 27 61 6D 65 00 0D + 	dta d"Game - Cannot Do                " 
   791
   792 				;-----------------
   793
   794 				;* Sound effects index  
   795
   796 1B1A			sfx_data
   797 1B1A 2E 1B			dta a(sfx_00)
   798 1B1C 58 1B			dta a(sfx_01)
   799 1B1E 72 1B			dta a(sfx_02)
   800 1B20 86 1B			dta a(sfx_03)
   801 1B22 A0 1B			dta a(sfx_04)
   802 1B24 DC 1B			dta a(sfx_05)
   803 1B26 EE 1B			dta a(sfx_06)
   804 1B28 10 1C			dta a(sfx_07)
   805 1B2A 38 1C			dta a(sfx_08)
   806 1B2C 7E 1C			dta a(sfx_09)  
   807
   808 				;* Sound effects data 
   809
   810 1B2E 5F A8 5F A6 5F A5 + sfx_00	ins '/Bunny Hop SFX/menu-press.sfx'
   811 1B58 5F A8 5F A6 2F A8 + sfx_01	ins '/Bunny Hop SFX/menu-movement.sfx'
   812 1B72 1D A7 3B A5 3B A3 + sfx_02	ins '/Bunny Hop SFX/menu-keyclick.sfx'
   813 1B86 1F C9 1F C9 EC A8 + sfx_03	ins '/Bunny Hop SFX/menu-code_rejected.sfx'
   814 1BA0 28 A9 28 A9 28 A8 + sfx_04	ins '/Bunny Hop SFX/menu-code_accepted.sfx'
   815 1BDC 1D A7 50 A8 50 A5 + sfx_05	ins '/Bunny Hop SFX/game-select_unselect.sfx'
   816 1BEE 07 01 05 02 04 03 + sfx_06	ins '/Bunny Hop SFX/game-move_fox.sfx'
   817 1C10 71 A7 38 A7 6B A7 + sfx_07	ins '/Bunny Hop SFX/game-move_bunny.sfx'
   818 1C38 3C A6 78 A8 78 A7 + sfx_08	ins '/Bunny Hop SFX/game-in_hole.sfx'
   819 1C7E 4C C8 4C C8 4C C8 + sfx_09	ins '/Bunny Hop SFX/game-cannot_do.sfx' 
   820
   821 				;-----------------
   822
   823 				;* Screen memory 
   824 					
   825 1C92 00 00 34 69 6D 65 + line_0	dta d"  Time: 00:00      LZSS Address: $0000  "
   826 1CBA 00 00 00 00 33 74 + line_1	dta d"    StartPtr: $0000   EndPtr: $0000     "
   827 1CE2 00 00 29 1A 00 04 + line_2	dta d"  I: $00  P: $00 C: $00 L: $00  F: $00  "
   828 1D0A 34 75 6E 65 00 10 + line_3	dta d"Tune 01/01: (insert title here)         "
   829 1D32 00 33 26 38 00 10 + line_4	dta d" SFX 01/01: (28 chars or less maybe)    "
   830 1D5A 00 00 00 00 00 34 + line_5	dta d"     Tune: Left/Right SFX: Up/Down      "
   831 1D82 00 00 30 72 65 73 + line_6	dta d"  Press 'Fire' to play the selected SFX "
   832 1DAA 00 24 35 2D 22 00 + line_7	dta d" DUMB Soundtest-LZSS by VinsCool   "
   833 1DCD F6 90 8E 91 00	line_7a	dta d"v0.1"*,$00
   834
   835 				;-----------------
   836
   837 				;* line counter spacing table for instrument speed from 1 to 16
   838
   839 				;-----------------
   840
   841 				;* the idea here is to pick the best sweet spots each VBI multiples to form 1 "optimal" table, for each region
   842 				;* it seems like the number of lines for the 'fix' value MUST be higher than either 156 for better stability
   843 				;* else, it will 'roll' at random, which is not good! better sacrifice a few lines to keep it stable...
   844 				;* strangely enough, NTSC does NOT suffer from this weird rolling effect... So that one can use values above or below 131 fine
   845
   846 				;	    x1  x2  x3  x4  x5  x6  x7  x8  x9  x10 x11 x12 x13 x14 x15 x16 
   847
   848 1DD2			tabppPAL	; "optimal" PAL timing table
   849 1DD2 9C 4E 34 27 20 1A + 	dta $9C,$4E,$34,$27,$20,$1A,$17,$14,$12,$10,$0F,$0D,$0C,$0C,$0B,$0A
   850 					
   851 1DE2			tabppPALfix	; interval offsets for timing stability 
   852 1DE2 9C 9C 9C 9C A0 9C + 	dta $9C,$9C,$9C,$9C,$A0,$9C,$A1,$A0,$A2,$A0,$A5,$9C,$9C,$A8,$A5,$A0
   853 					
   854 				;-----------------
   855 					
   856 				;* NTSC needs its own adjustment table too... And so will cross-region from both side... Yay numbers! 
   857 				;* adjustments between regions get a lot trickier however...
   858 				;* for example: 
   859 				;* 1xVBI NTSC to PAL, 130 on 156 does work for a stable rate, but it would get all over the place for another number 
   860
   861 				;	    x1  x2  x3  x4  x5  x6  x7  x8  x9  x10 x11 x12 x13 x14 x15 x16 
   862 					
   863 1DF2			tabppNTSC	; "optimal" NTSC timing table
   864 1DF2 82 41 2B 20 1A 15 + 	dta $82,$41,$2B,$20,$1A,$15,$12,$10,$0E,$0D,$0B,$0A,$0A,$09,$08,$08
   865
   866 1E02			tabppNTSCfix	; interval offsets for timing stability 
   867 1E02 82 82 81 80 82 7E + 	dta $82,$82,$81,$80,$82,$7E,$7E,$80,$7E,$82,$79,$78,$82,$7E,$78,$80
   868
   869 				;-----------------
   870
   871 				;* TODO: add cross region tables fix, might be a pain in the ass, blegh...
   872
   873 				;-----------------
   874
   875 				;* VBI address backup 
   876
   877 1E12			oldvbi	
   878 1E12 00 00			dta a(0) 
   879 					
   880 				;-----------------
   881
   882 				;* Display list 
   883
   884 1E14			dlist 
   885 1E14 70 70 70 70 70 70		:6 dta $70		; start with 6 empty lines
   886 1E1A 42				dta $42			; ANTIC mode 2 
   887 1E1B 92 1C			dta a(line_0)		; line_0 
   888 1E1D 70				:1 dta $70		; empty lines
   889 1E1E 02				dta $02			; line_1
   890 1E1F 70				:1 dta $70		; empty lines
   891 1E20 02				dta $02			; line_2
   892 1E21 70 70 70			:3 dta $70		; empty lines
   893 1E24 02 02			:2 dta $02		; line_3 and line_4
   894 1E26 70 70			:2 dta $70		; empty lines
   895 1E28 02				dta $02			; line_5
   896 1E29 70				:1 dta $70		; empty lines
   897 1E2A 02				dta $02			; line_6 
   898 1E2B 70 70 70 70			:4 dta $70		; empty lines
   899 1E2F 02				dta $02			; line_7 
   900 1E30 41 14 1E			dta $41,a(dlist)	; Jump and wait for vblank, return to dlist 
   901 02E0-02E1> 59 15			run start 		; run address was put here for simplicity, so it come after everything else in memory 
   902
   903 				;----------------- 
   904
   905 				;//---------------------------------------------------------------------------------------------
   906
   907 				;* And that's all folks :D
   908
   909 				;----------------- 
   910
   405
   406 				;-----------------
   407
   408 				;//---------------------------------------------------------------------------------------------
   409
   410 				;* Songs index and data will be inserted here, after everything else, that way they are easy to modify externally
   411
   412 				;	org SONGINDEX	
   413 1E33				icl "SongIndex.asm" 
Source: SongIndex.asm
     1 				;* Songs index always begin with the "intro" section, followed by the "loop" section, when applicable 
     2 				;* Index list must end with the dummy tune address to mark the end of each list properly 
     3 				;* Make sure to define the total number of tunes that could be indexed in code using it to avoid garbage data being loaded 
     4
     5 1E33			SongIndex 
     6 1E33-2F08> 39 1E 37 1E		dta a(SNG_0),a(SEQ_0) 
     7 				;	dta a(SNG_1),a(SEQ_1) 
     8 1E37			SongIndexEnd 
     9
    10 				;-----------------
    11 						
    12 				;//---------------------------------------------------------------------------------------------
    13
    14 1E37			SongSequence
    15 1E37 00 80		SEQ_0	dta $00,$80
    16 				/*
    17 				SEQ_0	dta $00,$00,$00,$00
    18 					dta $01,$01,$01,$01
    19 					dta $02,$02,$02,$02
    20 					dta $02,$02,$02,$02
    21 					dta $03,$03,$03,$03
    22 					dta $04,$04,$04,$04
    23 					dta $05,$05,$05,$05
    24 					dta $05,$05,$05,$05
    25 					dta $80
    26 				SEQ_1	dta $00,$80
    27 				*/
    27
    28 1E39			SongSequenceEnd 
    29
    30 				;-----------------
    31 						
    32 				;//---------------------------------------------------------------------------------------------
    33
    34 1E39			SongSection
    35 1E39 3D 1E		SNG_0	dta a(LZ00)
    36 				/*
    37 					dta a(LZ01) 
    38 					dta a(LZ04) 
    39 					dta a(LZ09) 
    40 					dta a(LZ16) 
    41 					dta a(LZ20) 
    42 					dta a(LZ25) 
    43 				SNG_1	dta a(LZ_FULL) 
    44 				*/
    44
    45 1E3B 09 2F		SNG_END	dta a(LZ_END) 
    46 1E3D			SongSectionEnd 
    47
    48 				;-----------------
    49 						
    50 				;//---------------------------------------------------------------------------------------------
    51
    52 				;* LZSS data, all in a single block
    53
    54 1E3D			LZ_DTA
    55 1E3D 81 00 00 00 A7 3F + LZ00	ins '/RANDOM3/Lab Stereo.lzss'
    56 				/*
    57 				LZ01	ins '/Sketch 44/Sketch 44.lz01'
    58 				LZ04	ins '/Sketch 44/Sketch 44.lz04'
    59 				LZ09	ins '/Sketch 44/Sketch 44.lz09'
    60 				LZ16	ins '/Sketch 44/Sketch 44.lz16'
    61 				LZ20	ins '/Sketch 44/Sketch 44.lz20'
    62 				LZ25	ins '/Sketch 44/Sketch 44.lz25'
    63 				LZ_FULL	ins '/Sketch 44/Sketch 44.lzss'
    64 				*/
    64
    65 2F09			LZ_END
    66
    67 				;-----------------
    68 						
    69 				;//---------------------------------------------------------------------------------------------
    70
   414 					
   415 				;-----------------
   416
   417 				;//---------------------------------------------------------------------------------------------
   418
