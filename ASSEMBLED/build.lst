mads 2.1.3
Source: lzssp.asm
     1 				;* When used in a project, the LZSS driver must be assembled from this file!
     2 				;* Include everything needed below, and edit accordingly.
     3
     4 				;-----------------
     5
     6 				;//---------------------------------------------------------------------------------------------
     7
     8 				;* Build flags, they are not the requirement, and could be changed if necessary 
     9
    10 					OPT R- F-
    11 					icl "atari.def"			; Missing or conflicting labels cause build errors, be extra careful! 
Source: atari.def
     1 				;* some memory addresses and definitions
     2
     3 				;//---------------------------------------------------------------------------------------------
     4
     5 = 000A			.def DOSVEC			= $000A
     6 = 0012			.def RTCLOK			= $0012	; Real Time Clock
     7
     8 = 0200			.def VDSLST			= $0200	; Display List Interrupt Vector
     9
    10 = 0222			.def VVBLKI			= $0222	; Vertical Blank Immediate (VBI) Register
    11 = 022F			.def SDMCTL			= $022F	; Shadow Direct Memory Access Control address
    12 = 0230			.def SDLSTL			= $0230
    13 = 02C4			.def COLOR0			= $02C4
    14 = 02C5			.def COLOR1			= $02C5
    15 = 02C6			.def COLOR2			= $02C6
    16 = 02C7			.def COLOR3			= $02C7
    17 = 02C8			.def COLOR4			= $02C8
    18 = 02F2			.def CH1			= $02F2
    19 = 02FC			.def CH				= $02FC
    20
    21 = D000			.def HPOSP0          		= $D000	; HORIZONTAL POSITION P0
    22 = D001			.def HPOSP1          		= $D001	; HORIZONTAL POSITION P1
    23 = D002			.def HPOSP2          		= $D002	; HORIZONTAL POSITION P2
    24 = D003			.def HPOSP3          		= $D003	; HORIZONTAL POSITION P3
    25 = D004			.def HPOSM0          		= $D004	; HORIZONTAL POSITION M0
    26 = D005			.def HPOSM1          		= $D005	; HORIZONTAL POSITION M1
    27 = D006			.def HPOSM2          		= $D006	; HORIZONTAL POSITION M2
    28 = D007			.def HPOSM3          		= $D007	; HORIZONTAL POSITION M3
    29 = D008			.def SIZEP0          		= $D008	; SIZE P0
    30 = D009			.def SIZEP1          		= $D009	; SIZE P0
    31 = D00A			.def SIZEP2          		= $D00A	; SIZE P0
    32 = D00B			.def SIZEP3          		= $D00B	; SIZE P0
    33 = D00C			.def SIZEM           		= $D00C	; SIZE M
    34 = D00D			.def GRAFP0          		= $D00D
    35 = D00E			.def GRAFP1          		= $D00E
    36 = D00F			.def GRAFP2          		= $D00F
    37 = D010			.def GRAFP3          		= $D010
    38 = D010			.def TRIG0			= $D010
    39 = D011			.def GRAFM           		= $D011
    40 = D012			.def COLPM0          		= $D012	; COLOR P0/M0
    41 = D013			.def COLPM1          		= $D013	; COLOR P1/M1
    42 = D014			.def COLPM2          		= $D014	; COLOR P2/M2
    43 = D014			.def NTSCPAL         		= $D014
    44 = D015			.def COLPM3          		= $D015	; COLOR P3/M3
    45 = D016			.def COLPF0         		= $D016
    46 = D017			.def COLPF1          		= $D017
    47 = D018			.def COLPF2          		= $D018
    48 = D019			.def COLPF3          		= $D019
    49 = D01A			.def COLBK           		= $D01A
    50 = D01B			.def GPRIOR          		= $D01B
    51 = D01D			.def GRACTL          		= $D01D
    52
    53 = D200			.def POKEY 			= $D200
    54 = D209			.def KBCODE			= $D209
    55 = D20A			.def RANDOM			= $D20A
    56 = D20B			.def POTGO 			= $D20B ; reset paddles for new input to read
    57 = D20E			.def IRQEN          		= $D20E
    58 = D20E			.def IRQST          		= $D20E
    59 = D20F			.def SKCTL			= $D20F
    60 = D20F			.def SKSTAT			= $D20F
    61
    62 = D300			.def PORTA			= $D300
    63 = D301			.def PORTB           		= $D301
    64
    65 = D400			.def DMACTL          		= $D400
    66 = D401			.def CHACTL          		= $D401
    67 = D402			.def DLISTL          		= $D402
    68 = D403			.def DLISTH          		= $D403
    69 = D404			.def HSCROL          		= $D404
    70 = D405			.def VSCROL          		= $D405
    71 = D407			.def PMBASE          		= $D407	; STARTING ADRESS PLAYER MISSILE GRAPHICS
    72 = D409			.def CHBASE          		= $D409
    73 = D40A			.def WSYNC           		= $D40A
    74 = D40B			.def VCOUNT          		= $D40B
    75 = D40E			.def NMIEN          		= $D40E 
    76 = D40F			.def NMIST           		= $D40F
    77 = D40F			.def NMIRES			= $D40F
    78
    79 = FFFA			.def NMI             		= $FFFA
    80 = FFFC			.def RESET           		= $FFFC
    81 = FFFE			.def IRQ             		= $FFFE
    82
    83 				;//---------------------------------------------------------------------------------------------
    84
    85 				.MACRO CHECK_NTSCPAL
    86 						lda		NTSCPAL
    87 						cmp		#1
    88 				.ENDM
    89
    90 				.MACRO SETBKCOL COLVAL
    91 				.ifdef DEBUG_COLOR
    92 						lda		#:COLVAL 
    93 						sta		COLBK
    94 				.endif
    95 				.ENDM
    96
    97 				.MACRO KIL
    98 						dta 2
    99 				.ENDM
   100
   101 				;//---------------------------------------------------------------------------------------------
   102
   103 = 0040			.def LMS                 	= 64
   104 = 0010			.def HS                  	= 16
   105 = 0004			.def MODE4               	= 4
   106 = 000D			.def MODED               	= $0D
   107 = 000E			.def MODEE               	= $0E
   108 = 000F			.def MODEF               	= $0F
   109 = 0070			.def BLANK8              	= $70
   110 = 0080			.def DLI                 	= 128
   111 = 0041			.def DLIJUMP             	= $41	; jump + wait vsync
   112 = 0001			.def DL_JUMP             	= $1	; jump 
   113 = 0000			.def PFSIZE_DISABLED		= 0
   114 = 0001			.def PFSIZE_NARROW		= 1
   115 = 0002			.def PFSIZE_NORMAL		= 2
   116 = 0003			.def PFSIZE_WIDE		= 3
   117 = 0002			.def GRACTL_PDMA		= 1<<1
   118 = 0001			.def GRACTL_MDMA		= 1<<0
    12
    13 				;-----------------
    14
    15 				;//---------------------------------------------------------------------------------------------
    16
    17 				;* ORG addresses can always be changed based on how memory is layed out, as long as it fits, it should work fine
    18
    19 = 0000			ZEROPAGE	equ $0000		; Zeropage, the addresses may be changed if necessary, required
    20 = 0800			DRIVER		equ $0800		; Unrolled LZSS driver by rensoupp, for LZSS data buffer and driver routines, required
    21 					
    22 				;* Below is a bunch of example addreses, they are not intended to be a requirement! 
    23 					
    24 				;SOUNDTEST	equ $2000		; Example program, optional 
    25 				;SONGINDEX	equ $3000		; Songs index and data, alligned memory for easier insertion from RMT, optional 
    26
    27 				;-----------------
    28
    29 				;//---------------------------------------------------------------------------------------------
    30
    31 				;* The Zeropage is a requirement, but could be edited is necessary 
    32
    33 					ORG ZEROPAGE
    34 				.PAGES 1
    35 					icl "lzsspZP.asm"
Source: lzsspZP.asm
     1 				.LOCAL ZPLZS
     2
     3 = 0000			SongPtr    	.ds     2
     4 = 0002			bptr		.ds     2		
     5 = 0004			bit_data        .ds     1
     6
     7 				.ENDL
    36 				.ENDPG
    37
    38 				;-----------------
    39
    40 				;//---------------------------------------------------------------------------------------------
    41
    42 				;* The unrolled LZSS driver + Buffer will be inserted here first, it is a requirement!
    43
    44 					org DRIVER
    45 				;	icl "playlzs16u.asm"
    46 					icl "playlzs16-dumb.asm"
Source: playlzs16-dumb.asm
     1 				;
     2 				; LZSS Compressed SAP player for 16 match bits
     3 				; --------------------------------------------
     4 				;
     5 				; (c) 2020 DMSC
     6 				; Code under MIT license, see LICENSE file.
     7 				;
     8 				; This player uses:
     9 				;  Match length: 8 bits  (1 to 256)
    10 				;  Match offset: 8 bits  (1 to 256)
    11 				;  Min length: 2
    12 				;  Total match bits: 16 bits
    13 				;
    14 				; Compress using:
    15 				;  lzss -b 16 -o 8 -m 1 input.rsap test.lz16
    16 				;
    17 				; Assemble this file with MADS assembler, the compressed song is expected in
    18 				; the `test.lz16` file at assembly time.
    19 				;
    20 				; The plater needs 256 bytes of buffer for each pokey register stored, for a
    21 				; full SAP file this is 2304 bytes.
    22 				;
    23
    24 					.ALIGN $100
    25 				buffers
    26 = 0800				.ds 256 * 9
    27
    28 				//////////////////////////////////
    29
    30 				.LOCAL LZS
    31 = 1100			chn_copy	.ds     9
    32 = 1109			chn_pos		.ds     9
    33 				;bptr		.ds     2
    34 = 1112			SongStartPtr	.ds     2
    35 = 1114			SongEndPtr	.ds     2
    36 				;song_ptr	.ds	2
    37 = 1116			cur_pos		.ds     1
    38 = 1117			chn_bitsInit	.ds     1
    39 = 1118			chn_bits	.ds     1
    40 = 1119			ptr_offset	.ds	1
    41 				;bit_data	.byte   1
    42 FFFF> 111A-1CE4> 00	Initialized	.byte   0
    43 				.ENDL
    44
    45 				//////////////////////////////////
    46
    47 				;* Check for ending of song and jump to the next frame
    48
    49 111B			LZSSCheckEndOfSong
    50 111B A5 01			lda ZPLZS.SongPtr+1
    51 111D CD 15 11			cmp LZS.SongEndPtr+1
    52 1120 D0 05			bne LZSSCheckEndOfSong_done
    53 1122 A5 00			lda ZPLZS.SongPtr
    54 1124 CD 14 11			cmp LZS.SongEndPtr
    55 1127			LZSSCheckEndOfSong_done
    56 1127 60				rts
    57
    58 1128			init_song
    59 1128 AD 12 11 85 00 AD + 	mwa LZS.SongStartPtr ZPLZS.SongPtr
    60 1132 20 A9 13			jsr SwapBufferReset
    61 1135 A0 00			ldy #0
    62 1137 84 02			sty ZPLZS.bptr			; Initialize buffer pointer
    63 1139 8C 16 11			sty LZS.cur_pos
    64 113C B1 00			lda (ZPLZS.SongPtr),y		; Get the first byte to set the channel bits
    65 113E 8D 17 11			sta LZS.chn_bitsInit
    66 1141 C8				iny
    67 1142 84 04			sty ZPLZS.bit_data		; always get new bytes
    68 1144 8C 1A 11			sty LZS.Initialized
    69 1147 A9 08			lda #>buffers			; Set the buffer offset 
    70 1149 8D 56 11			sta cbuf+2
    71 114C A2 08			ldx #8				; Init all channels
    72 114E			clear
    73 114E B1 00			lda (ZPLZS.SongPtr),y		; Read just init value and store into buffer and POKEY
    74 1150 C8				iny
    75 1151 9D CD 13			sta SDWPOK0,x
    76 1154			cbuf
    77 1154 8D FF 08			sta buffers+255
    78 1157 EE 56 11			inc cbuf+2
    79 115A CA				dex
    80 115B 10 F1			bpl clear
    81 115D 98				tya
    82 115E 18				clc
    83 115F 65 00			adc ZPLZS.SongPtr
    84 1161 85 00			sta ZPLZS.SongPtr
    85 1163 90 02 E6 01			scc:inc ZPLZS.SongPtr+1
    86 1167 A2 08			ldx #8
    87 1169			clear2
    88 1169 A9 00			lda #0
    89 116B 9D 00 11			sta LZS.chn_copy,x
    90 116E CA				dex 
    91 116F 10 F8			bpl clear2
    92 1171 60				rts
    93
    94 				;* Play one frame of the song
    95
    96 1172			LZSSPlayFrame
    97 1172 AD 1A 11			lda LZS.Initialized
    98 1175 F0 B1			beq init_song
    99 1177 A9 08			lda #>buffers
   100 1179 85 03			sta ZPLZS.bptr+1
   101 117B AD 17 11			lda LZS.chn_bitsInit
   102 117E 8D 18 11			sta LZS.chn_bits
   103 1181 A2 08			ldx #8				; Loop through all "channels", one for each POKEY register
   104 1183 A0 00			ldy #0 
   105 1185 8C 19 11			sty LZS.ptr_offset
   106
   107 1188			chn_loop:
   108 1188 4E 18 11			lsr LZS.chn_bits
   109 118B B0 39			bcs skip_chn			; C=1 : skip this channel
   110 118D BD 00 11			lda LZS.chn_copy, x		; Get status of this stream
   111 1190 D0 21			bne do_copy_byte		; If > 0 we are copying bytes
   112 1192 AC 19 11			ldy LZS.ptr_offset
   113
   114 				;* We are decoding a new match/literal
   115
   116 1195 46 04			lsr ZPLZS.bit_data		; Get next bit
   117 1197 D0 06			bne got_bit	
   118 1199 B1 00			lda (ZPLZS.SongPtr),y		; Not enough bits, refill!
   119 119B C8				iny
   120 119C 6A				ror				; Extract a new bit and add a 1 at the high bit (from C set above)
   121 119D 85 04			sta ZPLZS.bit_data
   122 					
   123 119F			got_bit:
   124 119F B1 00			lda (ZPLZS.SongPtr),y		; Always read a byte, it could mean "match size/offset" or "literal byte"
   125 11A1 C8				iny
   126 11A2 8C 19 11			sty LZS.ptr_offset
   127 11A5 B0 17			bcs store			; Bit = 1 is "literal", bit = 0 is "match"
   128 11A7 9D 09 11			sta LZS.chn_pos, x		; Store in "copy pos"
   129 11AA B1 00			lda (ZPLZS.SongPtr),y
   130 11AC C8				iny
   131 11AD 9D 00 11			sta LZS.chn_copy, x		; Store in "copy length"
   132 11B0 8C 19 11			sty LZS.ptr_offset
   133
   134 				;* And start copying first byte
   135
   136 11B3			do_copy_byte:
   137 11B3 DE 00 11			dec LZS.chn_copy, x		; Decrease match length, increase match position
   138 11B6 FE 09 11			inc LZS.chn_pos, x
   139 11B9 BC 09 11			ldy LZS.chn_pos, x
   140 11BC B1 02			lda (ZPLZS.bptr), y		; Now, read old data, jump to data store
   141 11BE			store:
   142 11BE AC 16 11			ldy LZS.cur_pos
   143 11C1 9D CD 13			sta SDWPOK0,x			; Store to output and buffer
   144 = 11C2				buffstore equ *-2
   145 11C4 91 02			sta (ZPLZS.bptr), y
   146 11C6			skip_chn:
   147 11C6 E6 03			inc ZPLZS.bptr+1		; Increment channel buffer pointer
   148 11C8 CA				dex
   149 11C9 10 BD			bpl chn_loop			; Next channel
   150 11CB EE 16 11			inc LZS.cur_pos
   151 11CE A5 00			lda ZPLZS.SongPtr
   152 11D0 18				clc
   153 11D1 6D 19 11			adc LZS.ptr_offset
   154 11D4 85 00			sta ZPLZS.SongPtr
   155 11D6 90 02 E6 01			scc:inc ZPLZS.SongPtr+1
   156 11DA 60				rts
   157
   158 				;* Et voilà :D
   159
    47
    48 				;-----------------
    49
    50 				;//---------------------------------------------------------------------------------------------
    51 				               
    52 				;* Several subroutines added for VUPlayer have been split to become part of the driver itself, allowing new features for future projects easily!
    53
    54 				;-----------------
    55
    56 				;* Song index initialisation subroutine, load pointers using index number, as well as loop point when it exists 
    57 				           
    58 11DB			SetNewSongPtrsFull 			; if the routine is called from this label, index and loop are restarted
    59 11DB A2 00			ldx #0
    60 11DD 8E 42 12			stx is_fadeing_out		; reset fadeout flag, the new index is loaded from start
    61 11E0 8E 07 12			stx is_looping 			; reset the loop counter, the new index is loaded from start 
    62 11E3 8E 1D 12			stx loop_count
    63 11E6 A9 00			lda #0				; current tune index, must be set before the routine is executed
    64 = 11E7				SongIdx equ *-1 
    65 11E8 0A				asl @				; multiply by 2, for the hi and lo bytes of each address 
    66 11E9 0A				asl @				; multiply again, offset each songs by 4 bytes
    67 11EA AA				tax 
    68 11EB BD E5 1C			lda SongIndex,x
    69 11EE 8D 2D 12			sta SongPtr+0
    70 11F1 E8				inx 
    71 11F2 BD E5 1C			lda SongIndex,x
    72 11F5 8D 2E 12			sta SongPtr+1
    73 11F8 E8				inx 
    74 11F9 BD E5 1C			lda SongIndex,x
    75 11FC 8D 09 12			sta SectionPtr+0
    76 11FF E8				inx 
    77 1200 BD E5 1C			lda SongIndex,x
    78 1203 8D 0A 12			sta SectionPtr+1
    79 					
    80 1206			SetNewSongPtrs 				; if the routine is called from this label, it will use the current parameters instead 
    81 1206 A0 00			ldy #0 
    82 = 1207				is_looping equ *-1 
    83 1208 B9 FF FF			lda $FFFF,y
    84 = 1209				SectionPtr equ *-2 
    85 120B 10 1B			bpl SetNewSongPtrs_c
    86 					
    87 120D			SetNewSongPtrs_a
    88 120D C9 FF			cmp #$FF
    89 120F D0 03			bne SetNewSongPtrs_b
    90 1211 4C 8A 12			jmp stop_toggle
    91
    92 1214			SetNewSongPtrs_b
    93 1214 29 7F			and #$7F
    94 1216 8D 07 12			sta is_looping
    95 				;	bpl SetNewSongPtrs
    96 1219 EE 1D 12			inc loop_count
    97 121C A9 00			lda #0
    98 = 121D				loop_count equ *-1
    99 121E C9 02			cmp #2
   100 1220 D0 E4			bne SetNewSongPtrs
   101 1222 20 39 13			jsr trigger_fade_immediate
   102 1225 4C 06 12			jmp SetNewSongPtrs
   103
   104 1228			SetNewSongPtrs_c	
   105 1228 0A				asl @
   106 1229 AA				tax
   107 122A A0 00			ldy #0
   108 					
   109 122C			SetNewSongPtrs_d
   110 122C BD FF FF			lda $FFFF,x
   111 = 122D				SongPtr equ *-2
   112 122F 99 12 11			sta LZS.SongStartPtr,y
   113 1232 E8				inx
   114 1233 C8				iny
   115 1234 C0 04			cpy #4
   116 1236 90 F4			bcc SetNewSongPtrs_d
   117 1238 EE 07 12			inc is_looping 
   118
   119 123B			SetNewSongPtrsDone
   120 123B A9 00			lda #0
   121 123D 8D 1A 11			sta LZS.Initialized		; reset the state of the LZSS driver to not initialised so it can play the next tune or loop 
   122 1240 60				rts 	
   123
   124 				;-----------------
   125
   126 				;* Volume fadeout subroutine
   127
   128 1241			fade_volume_loop 
   129 1241 A9 00			lda #0			; fadeing out timer and flag
   130 = 1242				is_fadeing_out equ *-1 
   131 1243 F0 37			beq fade_volume_done	; equal 0 means it is not set, and must be skipped
   132 1245 10 0B			bpl continue_fadeout	; above 0 means it is already set, skip initialising again 
   133 1247			begin_fadeout			; below 0 means it is set, and must be initialised first 
   134 1247 A9 01			lda #1			; unit of volume to subtract
   135 1249 8D 42 12			sta is_fadeing_out	; flag and initial fade volume set
   136 124C AD 5B 13			lda v_second		; current second
   137 124F 8D 79 12			sta last_second_seen	; initialise the timer for fadeout
   138 1252			continue_fadeout	
   139 1252 A0 07			ldy #7			; index from the 4th AUDC 
   140 1254			fade_volume_loop_a
   141 1254 B9 CD 13			lda SDWPOK0,y		; current POKEY buffer
   142 = 1255				bufffade1 equ *-2
   143 1257 AA				tax			; backup for the next step
   144 1258 29 0F			and #$0F		; keep only the volume values
   145 125A 38				sec			; set carry for the subtraction
   146 125B ED 42 12			sbc is_fadeing_out	; subtract the fading value directly
   147 125E F0 0E			beq volume_loop_again	; if value = 0, write that value directly
   148 1260 10 04			bpl set_new_volume	; else if the subtraction did not overflow, continue with the next step
   149 1262 A9 00			lda #0			; else, set the volume to 0 
   150 1264 F0 08			beq volume_loop_again	; unconditional 
   151 1266			set_new_volume	
   152 1266 8D 6D 12			sta ora_volume		; this value will be used for the ORA instruction 
   153 1269 8A				txa			; get back the AUDC value loaded a moment before
   154 126A 29 F0			and #$F0		; only keep the Distortion bits
   155 126C 09 00			ora #0			; combine the new volume to it
   156 = 126D				ora_volume equ *-1
   157 126E			volume_loop_again
   158 126E 99 CD 13			sta SDWPOK0,y		; write the new AUDC value in memory for later
   159 = 126F				bufffade2 equ *-2
   160 1271 88 88			:2 dey			; decrement twice to only load the AUDC
   161 1273 10 DF			bpl fade_volume_loop_a	; continue this loop until Y overflows to $FF 
   162 1275 AD 5B 13			lda v_second		; current second count
   163 1278 C9 00			cmp #0			; compare to the last second loaded 
   164 = 1279				last_second_seen equ *-1
   165 127A D0 01			bne fade_increment
   166 127C			fade_volume_done
   167 127C 60				rts
   168 127D			fade_increment
   169 127D 8D 79 12			sta last_second_seen
   170 1280 EE 42 12			inc is_fadeing_out	; increment the fadeout value to subtract by 1 
   171 1283 AD 42 12			lda is_fadeing_out	; load that value for the comparison 
   172 1286 C9 0B			cmp #11			; 10 seconds must have passed to reach 10 units
   173 1288 90 F2			bcc fade_volume_done	; if the value is below the count, done 
   174
   175 				;-----------------
   176
   177 				;* Toggle Stop, similar to pause, except Play will restart the tune from the beginning
   178 				;* The routine will continue into the following subroutines, a RTS will be found at the end of setpokeyfull further below 
   179
   180 128A			stop_toggle 
   181 128A AD 27 13			lda is_playing_flag 
   182 128D 10 01			bpl set_stop			; the Stop flag will be set, regardless of Playing or being Paused 
   183 128F 60				rts				; otherwise, the player is stopped already 
   184 1290			set_stop
   185 1290 A9 FF			lda #$FF
   186 1292 8D 27 13			sta is_playing_flag		; #$FF -> Stop
   187 1295 20 DB 11			jsr SetNewSongPtrsFull 		; TODO: fix the index code, the tune won't restart properly  
   188 1298 20 74 13			jsr reset_timer 		; clear the timer, unlike PAUSE, which would freeze the values until it is unpaused
   189 					
   190 				;-----------------
   191
   192 				;* Stop/Pause the player and reset the POKEY registers, a RTS will be found at the end of setpokeyfull further below 
   193
   194 129B			stop_pause_reset
   195 129B A9 00			lda #0			; default values
   196 129D A0 08			ldy #8
   197 129F			stop_pause_reset_a 
   198 129F 99 CD 13			sta SDWPOK0,y		; clear the POKEY values in memory 
   199 12A2 99 D7 13			sta SDWPOK1,y		; write to both POKEYs even if there is no Stereo setup, that won't harm anything
   200 12A5 88				dey 
   201 12A6 10 F7			bpl stop_pause_reset_a	; repeat until all channels were cleared 
   202
   203 				;----------------- 
   204
   205 				;* Setpokey, intended for double buffering the decompressed LZSS bytes as fast as possible for timing and cosmetic purpose
   206
   207 12A8			setpokeyfull
   208 12A8 AD D6 13			lda POKSKC0 
   209 12AB 8D 0F D2			sta $D20F 
   210 12AE AC D5 13			ldy POKCTL0
   211 12B1 AD CD 13			lda POKF0
   212 12B4 AE CE 13			ldx POKC0
   213 12B7 8D 00 D2			sta $D200
   214 12BA 8E 01 D2			stx $D201
   215 12BD AD CF 13			lda POKF1
   216 12C0 AE D0 13			ldx POKC1
   217 12C3 8D 02 D2			sta $D202
   218 12C6 8E 03 D2			stx $D203
   219 12C9 AD D1 13			lda POKF2
   220 12CC AE D2 13			ldx POKC2
   221 12CF 8D 04 D2			sta $D204
   222 12D2 8E 05 D2			stx $D205
   223 12D5 AD D3 13			lda POKF3
   224 12D8 AE D4 13			ldx POKC3
   225 12DB 8D 06 D2			sta $D206
   226 12DE 8E 07 D2			stx $D207
   227 12E1 8C 08 D2			sty $D208
   228
   229 				;* 0 == Mono, FF == Stereo, 1 == Dual Mono (only SwapBuffer is necessary for it) 
   230
   231 12E4 A9 FF			lda #STEREO
   232 = 12E5				is_stereo_flag equ *-1
   233 12E6 D0 01			bne setpokeyfullstereo
   234 12E8 60				rts
   235
   236 12E9			setpokeyfullstereo
   237 12E9 AD E0 13			lda POKSKC1 
   238 12EC 8D 1F D2			sta $D21F 
   239 12EF AC DF 13			ldy POKCTL1
   240 12F2 AD D7 13			lda POKF4
   241 12F5 AE D8 13			ldx POKC4
   242 12F8 8D 10 D2			sta $D210
   243 12FB 8E 11 D2			stx $D211
   244 12FE AD D9 13			lda POKF5
   245 1301 AE DA 13			ldx POKC5
   246 1304 8D 12 D2			sta $D212
   247 1307 8E 13 D2			stx $D213
   248 130A AD DB 13			lda POKF6
   249 130D AE DC 13			ldx POKC6
   250 1310 8D 14 D2			sta $D214
   251 1313 8E 15 D2			stx $D215
   252 1316 AD DD 13			lda POKF7
   253 1319 AE DE 13			ldx POKC7
   254 131C 8D 16 D2			sta $D216
   255 131F 8E 17 D2			stx $D217
   256 1322 8C 18 D2			sty $D218
   257 1325 60				rts
   258
   259 				;-----------------
   260
   261 				; Toggle Play/Pause 
   262
   263 1326			play_pause_toggle 
   264 1326 A9 00			lda #0
   265 = 1327				is_playing_flag equ *-1 	; #0 -> Play, #1 -> Pause, #$FF -> Stop 
   266 1328 F0 09			beq set_pause	
   267 132A			set_play 
   268 132A A9 00			lda #0				; reset the Play flag, regardless of being Paused or Stopped  
   269 132C 8D 27 13			sta is_playing_flag		; #0 -> Play
   270 132F 8D 42 12			sta is_fadeing_out		; reset the fadeing out flag, in case it was set before pausing 
   271 1332 60				rts
   272 1333			set_pause 
   273 1333 EE 27 13			inc is_playing_flag		; #0 -> #1 -> Pause 
   274 1336 4C 9B 12			jmp stop_pause_reset		; clear the POKEY registers, end with a RTS
   275 					
   276 				;-----------------
   277
   278 				;* This routine provides the ability to initialise a fadeout for anything that may require a transition in a game/demo 
   279 				;* At the end of the routine, the is_playing flag will be set to a 'stop', which will indicate the fadeout has been completed
   280 				;* If a new tune index is loaded during a fadeout, it will be interrupted, and play the next tune like normal instead 
   281 					
   282 1339			trigger_fade_immediate 
   283 1339 AD 27 13			lda is_playing_flag	; is the player currently in 'play' mode? 
   284 133C D0 08			bne trigger_fade_done	; if not, skip this subroutine, there is nothing to fadeout 
   285 133E AD 42 12			lda is_fadeing_out	; is the tune currently playing already engaged in a fadeout?
   286 1341 D0 03			bne trigger_fade_done	; if not 0, there is a fadeout in progress! skip this subroutine
   287 1343 CE 42 12			dec is_fadeing_out	; $00 -> $FF, the fadeout flag is set
   288 1346			trigger_fade_done
   289 1346 60				rts 
   290 					
   291 				;-----------------
   292
   293 1347			calculate_time 
   294 1347 AD 27 13			lda is_playing_flag 
   295 134A D0 27			bne notimetolose	; not playing -> no time counter increment  
   296 134C CE 58 13			dec v_frame		; decrement the frame counter
   297 134F D0 22			bne notimetolose	; not 0 -> a second did not yet pass
   298 1351 A9 00			lda #0
   299 = 1352			framecount equ *-1		; 50 or 60, defined by the region initialisation
   300 1353 8D 58 13			sta v_frame		; reset the frame counter
   301 1356 D0 01			bne addasecond		; unconditional
   302 1358 EA				nop
   303 = 1358			v_frame equ *-1			; the NOP instruction is overwritten by the frame counter	
   304 1359			addasecond
   305 1359 F8				sed			; set decimal flag first
   306 135A A9 00			lda #0
   307 = 135B			v_second equ *-1
   308 135C 18				clc			; clear the carry flag first, the keyboard code could mess with this part now...
   309 135D 69 01			adc #1			; carry flag is clear, add 1 directly
   310 135F 8D 5B 13			sta v_second
   311 1362 C9 60			cmp #$60		; 60 seconds, must be a HEX value!
   312 1364 D0 0C			bne cleardecimal 	; if not equal, no minute increment
   313 1366 A0 00			ldy #0			; will be used to clear values quicker
   314 1368			addaminute
   315 1368 A9 00			lda #0
   316 = 1369			v_minute equ *-1
   317 136A 69 00			adc #0			; carry flag is set above, adding 0 will add 1 instead
   318 136C 8D 69 13			sta v_minute
   319 136F 8C 5B 13			sty v_second		; reset the second counter
   320 1372			cleardecimal 
   321 1372 D8				cld			; clear decimal flag 
   322 1373			notimetolose
   323 1373 60				rts
   324 					
   325 				;-----------------
   326
   327 1374			reset_timer
   328 1374 A9 00			lda #0
   329 1376 8D 5B 13			sta v_second		; reset the seconds counter
   330 1379 8D 69 13			sta v_minute		; reset the minutes counter
   331 137C AD 52 13			lda framecount		; number of frames defined at initialisation  
   332 137F 8D 58 13			sta v_frame		; reset the frames counter 
   333 1382 60				rts
   334 					
   335 				;-----------------
   336
   337 				; Check the Volume Only bit in CH1, if set but below the $Fx range, it's used, else, it's proper Volume Only output
   338
   339 1383			CheckForTwoToneBit		
   340 1383 A0 01			ldy #1
   341 1385 BE CD 13			ldx SDWPOK0,y		; AUDC1
   342 = 1386				bufftwo equ *-2
   343 1388 E0 F0			cpx #$F0		; is the tune expected to run with Proper Volume Only output?
   344 138A B0 0F			bcs NoTwoTone		; if equal or above, this is not used for Two-Tone, don't set it
   345 138C 8A				txa
   346 138D 29 10			and #$10		; test the Volume Only bit
   347 138F F0 0A			beq NoTwoTone		; if it is not set, there is no Two-Tone Filter active
   348 1391 8A				txa
   349 1392 49 10			eor #$10		; reverse the Volume Only bit
   350 1394 99 CD 13			sta SDWPOK0,y		; overwrite the AUDC
   351 = 1395				bufftone equ *-2
   352 1397 A9 8B			lda #$8B		; set the Two-Tone Filter output
   353 1399 D0 02			bne SetTwoTone		; unconditional 
   354 139B			NoTwoTone
   355 139B A9 03			lda #3			; default SKCTL register state
   356 139D			SetTwoTone
   357 139D A0 09			ldy #9
   358 139F 99 CD 13			sta SDWPOK0,y		; overwrite the buffered SKCTL byte with the new value
   359 = 13A0				buffbit equ *-2
   360 13A2 60				rts
   361
   362 				;-----------------
   363
   364 				;* Swap POKEY buffers for Stereo Playback
   365 				;* This is a really dumb hack that shouldn't harm the LZSS driver if everything works as expected... 
   366
   367 13A3			SwapBuffer
   368 13A3 A9 D7			lda #<SDWPOK1
   369 13A5 C9 CD			cmp #<SDWPOK0
   370 = 13A6				buffset equ *-1
   371 13A7 D0 02			bne SwapBufferSet
   372 13A9			SwapBufferReset
   373 13A9 A9 CD			lda #<SDWPOK0
   374 13AB			SwapBufferSet
   375 13AB 8D A6 13			sta buffset
   376 13AE 8D C2 11			sta buffstore
   377 13B1 8D 55 12			sta bufffade1 
   378 13B4 8D 6F 12			sta bufffade2 
   379 13B7 8D 86 13			sta bufftwo
   380 13BA 8D 95 13			sta bufftone
   381 13BD 8D A0 13			sta buffbit
   382 13C0			SwapBufferDone
   383 13C0 60				rts
   384 					
   385 13C1			SwapBufferCopy
   386 13C1 A0 09			ldy #9
   387 13C3			SwapBufferLoop
   388 13C3 B9 CD 13			lda SDWPOK0,y
   389 13C6 99 D7 13			sta SDWPOK1,y
   390 13C9 88				dey
   391 13CA 10 F7			bpl SwapBufferLoop
   392 13CC 60				rts
   393
   394 				;-----------------
   395
   396 				;* Left POKEY
   397
   398 13CD			SDWPOK0 
   399 13CD 00			POKF0	dta $00
   400 13CE 00			POKC0	dta $00
   401 13CF 00			POKF1	dta $00
   402 13D0 00			POKC1	dta $00
   403 13D1 00			POKF2	dta $00
   404 13D2 00			POKC2	dta $00
   405 13D3 00			POKF3	dta $00
   406 13D4 00			POKC3	dta $00
   407 13D5 00			POKCTL0	dta $00
   408 13D6 03			POKSKC0	dta $03	
   409
   410 				;* Right POKEY
   411
   412 13D7			SDWPOK1	
   413 13D7 00			POKF4	dta $00
   414 13D8 00			POKC4	dta $00
   415 13D9 00			POKF5	dta $00
   416 13DA 00			POKC5	dta $00
   417 13DB 00			POKF6	dta $00
   418 13DC 00			POKC6	dta $00
   419 13DD 00			POKF7	dta $00
   420 13DE 00			POKC7	dta $00
   421 13DF 00			POKCTL1	dta $00
   422 13E0 03			POKSKC1	dta $03
   423
   424 				;-----------------
   425
   426 				;//---------------------------------------------------------------------------------------------
   427
   428 				;* To be able to use all the subroutines, include lzssp.asm in the project that may use the driver, 
   429 				;* Alternatively, include the code directly below  
   430 				;* The ORG addresses could be changed or even omitted if necessary! 
   431 					
   432 				;	org SOUNDTEST			
   433 13E1				icl "DUMB_Soundtest.asm"	; example program by VinsCool 
Source: DUMB_Soundtest.asm
     1 				;* --- Dumb Unless Made Better ---
     2 				;*
     3 				;* DUMB Soundtest-LZSS v0.1
     4 				;*
     5 				;* An attempt for a flexible LZSS music driver for the Atari 8-bit
     6 				;* By VinsCool, being worked on from July 27th to July 30th 2022 
     7 				;*
     8 				;* To build: 'mads lzssp.asm -l:ASSEMBLED/build.lst -o:ASSEMBLED/build.xex' 
     9
    10 				;-----------------
    11
    12 				;//---------------------------------------------------------------------------------------------
    13
    14 				; song speed xVBI
    15
    16 = 0001			SongSpeed	equ 1		; 1 => 50/60hz, 2 => 100/120hz, etc
    17
    18 				; playback speed will be adjusted accordingly in the other region
    19
    20 = 0000			REGIONPLAYBACK	equ 0		; 0 => PAL, 1 => NTSC
    21
    22 				; Stereo is now supported with the LZSS driver!
    23
    24 = 00FF			STEREO		equ 255		; 0 => MONO, 255 => STEREO, 1 => DUAL MONO
    25
    26 = 00FE			DISPLAY 	equ $FE		; Display List indirect memory address
    27
    28 				;* Subtune index number is offset by 1, meaning the subtune 0 would be subtune 1 visually
    29
    30 = 0002			TUNE_NUM	equ (SongIndexEnd-SongIndex)/4
    31
    32 				;* Sound effects index number will be displayed the same way for simplicity
    33
    34 = 000A			SFX_NUM		equ 10		; Bunny Hop SFX by PG 
    35
    36 = 0008			VLINE		equ 8		; 16 is the default according to Raster's example player 
    37 = 0069			RASTERBAR	equ $69		; $69 is a nice purpleish hue 
    38
    39 				;-----------------
    40
    41 				;//---------------------------------------------------------------------------------------------
    42
    43 				;* Initialisation, then loop infinitely unless the program is told otherwise 
    44
    45 13E1			start       
    46 13E1 A2 00			ldx #0			; disable playfield and the black colour value
    47 13E3 8E 2F 02			stx SDMCTL		; write to Shadow Direct Memory Access Control address
    48 13E6 20 0D 15			jsr wait_vblank		; wait for vblank before continuing
    49 13E9 8E C8 02			stx COLOR4		; Shadow COLBK (background colour), black
    50 13EC 8E C6 02			stx COLOR2		; Shadow COLPF2 (playfield colour 2), black
    51 13EF A9 C6 8D 30 02 A9 + 	mwa #dlist SDLSTL	; Start Address of the Display List
    52 13F9 8E E7 11			stx SongIdx 		; default tune index number
    53 13FC 8E F1 16			stx SfxIdx 		; default sfx index number
    54 13FF 20 9C 17			jsr set_index_count 	; print number of tunes and sfx indexed in memory
    55 1402 20 60 17			jsr set_tune_name	; print the tune name 
    56 1405 20 77 17			jsr set_sfx_name	; print the sfx name
    57 1408 20 A2 15			jsr detect_region
    58 140B 20 8A 12			jsr stop_toggle
    59 140E A2 22			ldx #$22		; DMA enable, normal playfield
    60 1410 8E 2F 02			stx SDMCTL		; write to Shadow Direct Memory Access Control address
    61 1413 A2 32			ldx #50	
    62 1415			wait_init   
    63 1415 20 0D 15			jsr wait_vblank		; wait for vblank => 50 frames
    64 1418 CA				dex			; decrement index x
    65 1419 D0 FA			bne wait_init		; repeat until x = 0, total wait time is ~2 seconds
    66 141B			init_done
    67 141B 78				sei			; Set Interrupt Disable Status
    68 141C AD 22 02 8D C4 1C + 	mwa VVBLKI oldvbi       ; vbi address backup
    69 1428 A9 D2 8D 22 02 A9 + 	mwa #vbi VVBLKI		; write our own vbi address to it 
    70 1432 A9 40 8D 0E D4		mva #$40 NMIEN		; enable vbi interrupts
    71 1437			wait_sync
    72 1437 AD 0B D4			lda VCOUNT		; current scanline 
    73 143A C9 08			cmp #VLINE		; will stabilise the timing if equal
    74 143C 90 F9			bcc wait_sync		; nope, repeat 
    75 143E 20 26 13			jsr play_pause_toggle	; now is the good time to toggle play
    76 					
    77 				;-----------------
    78
    79 				;//---------------------------------------------------------------------------------------------
    80
    81 				;* main loop, code runs from here ad infinitum after initialisation
    82
    83 1441			loop
    84 1441 A0 69			ldy #RASTERBAR			; custom rasterbar colour
    85 = 1442			rasterbar_colour equ *-1
    86 1443			acpapx1
    87 1443 AD 5C 14			lda spap
    88 1446 A2 00			ldx #0
    89 = 1447			cku	equ *-1
    90 1448 D0 1B			bne keepup
    91 144A AD 0B D4			lda VCOUNT			; vertical line counter synchro
    92 144D AA				tax
    93 144E 38 E9 08			sub #VLINE
    94 = 1450			lastpap	equ *-1
    95 1451 B0 02 69 FF			scs:adc #$ff
    96 = 1454			ppap	equ *-1
    97 1455 8D 5F 14			sta dpap
    98 1458 8E 50 14			stx lastpap
    99 145B A9 00			lda #0
   100 = 145C			spap	equ *-1
   101 145D 38 E9 00			sub #0
   102 = 145F			dpap	equ *-1
   103 1460 8D 5C 14			sta spap
   104 1463 B0 DE			bcs acpapx1
   105 1465			keepup
   106 1465 69 FF			adc #$ff
   107 = 1466			acpapx2	equ *-1
   108 1467 8D 5C 14			sta spap
   109 146A A2 00			ldx #0
   110 146C B0 01 E8			scs:inx
   111 146F 8E 47 14			stx cku
   112 1472			check_play_flag
   113 1472 AD 27 13			lda is_playing_flag 		; 0 -> is playing, else it is either stopped or paused 
   114 1475 D0 50			bne do_sfx			; in this case, nothing will happen until it is changed back to 0 
   115 1477 8C 1A D0			sty COLBK			; background colour 
   116 147A			do_play
   117 147A 20 A8 12			jsr setpokeyfull		; update the POKEY registers first, for both the SFX and LZSS music driver 
   118 147D 20 72 11			jsr LZSSPlayFrame		; Play 1 LZSS frame
   119 1480 20 83 13			jsr CheckForTwoToneBit		; if set, the Two-Tone Filter will be enabled 
   120 1483 AD E5 12			lda is_stereo_flag		; What is the current setup?
   121 1486 F0 16			beq dont_swap			; Mono detected -> do nothing 
   122 1488 30 05			bmi do_swap			; Stereo detected -> swap Left and Right POKEY pointers
   123 148A 20 C1 13			jsr SwapBufferCopy		; Dual Mono detected -> copy the Left POKEY to Right POKEY directly
   124 148D 30 0F			bmi dont_swap			; Unconditional, the subroutine return with the value of $FF in Y 
   125 148F			do_swap	
   126 148F 20 A3 13			jsr SwapBuffer 			; swap the POKEY memory addresses for Stereo playback 
   127 1492 20 72 11			jsr LZSSPlayFrame		; Play 1 LZSS frame (for Right POKEY) 
   128 1495 20 83 13			jsr CheckForTwoToneBit		; check for Two-Tone again too
   129 1498 20 41 12			jsr fade_volume_loop		; hah! got ya with this one running first this time, again for the same purpose
   130 149B 20 A3 13			jsr SwapBuffer			; revert to the original memory addresses for the next frame
   131 149E			dont_swap
   132 149E 20 41 12			jsr fade_volume_loop		; run the fadeing out code from here until it's finished
   133 14A1 AD 27 13			lda is_playing_flag		; was the player paused/stopped after fadeing out?
   134 				;	bne do_sfx			; if not equal, it was most likely stopped, and so there is nothing else to do here 
   135 14A4 F0 19			beq do_play_next		; if equal, continue
   136 14A6			do_loop
   137 14A6 AC FF 15			ldy tune_index
   138 14A9 C8				iny
   139 14AA CC A5 17			cpy SongTotal
   140 14AD 90 04			bcc seek_next
   141 14AF F0 02			beq seek_next
   142 14B1 A0 01			ldy #1
   143 14B3			seek_next
   144 14B3 8C FF 15			sty tune_index
   145 				;	dey
   146 14B6 8C E7 11			sty SongIdx
   147 14B9			do_loop_ok
   148 14B9 20 DB 11			jsr SetNewSongPtrsFull
   149 14BC 20 26 13			jsr play_pause_toggle
   150 14BF			do_play_next
   151 14BF 20 1B 11			jsr LZSSCheckEndOfSong		; is the current LZSS index done playing?
   152 14C2 D0 03			bne do_sfx			; if not, go back to the loop and wait until the next call
   153 14C4 20 06 12			jsr SetNewSongPtrs		; update the subtune index for the next one in adjacent memory 
   154 14C7			do_sfx
   155 14C7 20 0E 17			jsr play_sfx			; process the SFX data, if an index is queued and ready to play for this frame 
   156 14CA A0 00			ldy #$00			; black colour value
   157 14CC 8C 1A D0			sty COLBK			; background colour
   158 14CF 4C 41 14			jmp loop			; unconditional
   159
   160 				;----------------- 
   161
   162 				;//---------------------------------------------------------------------------------------------
   163
   164 				;* VBI loop, run through all the code that is needed, then return with a RTI 
   165
   166 14D2			vbi 
   167 14D2 8D 0A D4			sta WSYNC
   168 14D5			check_key_pressed 
   169 14D5 AE 0F D2			ldx SKSTAT		; Serial Port Status
   170 14D8 8A				txa
   171 14D9 29 04			and #$04		; last key still pressed?
   172 14DB D0 16			bne continue		; if not, skip ahead, no input to check 
   173 14DD AD 09 D2			lda KBCODE		; Keyboard Code  
   174 14E0 29 3F			and #$3F		; clear the SHIFT and CTRL bits out of the key identifier for the next part
   175 14E2 A8				tay
   176 14E3 8A				txa
   177 14E4 29 08			and #$08		; SHIFT key being held?
   178 14E6 F0 04			beq skip_held_key_check	; if yes, skip the held key flag check, else, verify if the last key is still being held
   179 14E8			check_keys_always
   180 14E8 A9 00			lda #0 			; was the last key pressed also held for at least 1 frame? This is a measure added to prevent accidental input spamming
   181 = 14E9				held_key_flag equ *-1
   182 14EA 30 0C			bmi continue_b		; the held key flag was set if the value is negative! skip ahead immediately in this case 
   183 14EC			skip_held_key_check
   184 14EC 20 B9 17			jsr check_keys		; each 'menu' entry will process its action, and return with RTS, the 'held key flag' must then be set!
   185 14EF A2 FF			ldx #$FF
   186 14F1 30 02			bmi continue_a		; skip ahead and set the held key flag! 
   187 14F3			continue			; do everything else during VBI after the keyboard checks 
   188 14F3 A2 00			ldx #0			; reset the held key flag! 
   189 14F5			continue_a 			; a new held key flag is set when jumped directly here
   190 14F5 8E E9 14			stx held_key_flag 
   191 14F8			continue_b 			; a key was detected as held when jumped directly here 
   192 14F8 20 5C 16			jsr check_joystick	; check the inputs for tunes and sfx index 
   193 14FB 20 47 13			jsr calculate_time 	; update the timer, this one is actually necessary, so even with DMA off, it will be executed
   194 14FE 20 3A 17			jsr check_tune_index
   195 1501 20 C9 15			jsr print_player_infos	; print most of the stuff on screen using printhex or printinfo in bulk 
   196 1504			continue_c
   197 1504 8D 0A D4			sta WSYNC
   198 1507			return_from_vbi	
   199 1507 68				pla			;* since we're in our own vbi routine, pulling all values manually is required! 
   200 1508 A8				tay
   201 1509 68				pla
   202 150A AA				tax
   203 150B 68				pla
   204 150C 40				rti			; return from interrupt, this ends the VBI time, whenever it actually is "finished" 
   205
   206 				;-----------------
   207
   208 				;//---------------------------------------------------------------------------------------------
   209
   210 				;* Everything below this point is either stand alone subroutines that can be called at any time, and the display list 
   211
   212 				;//---------------------------------------------------------------------------------------------
   213
   214 				;* Wait for vblank subroutine
   215
   216 150D			wait_vblank 
   217 150D A5 14			lda RTCLOK+2		; load the real time frame counter to accumulator
   218 150F			wait        
   219 150F C5 14			cmp RTCLOK+2		; compare to itself
   220 1511 F0 FC			beq wait		; equal means it vblank hasn't began
   221 1513 60				rts
   222
   223 				;-----------------
   224
   225 				; Print text from data tables, useful for many things 
   226
   227 1514			printinfo 
   228 1514 8C 21 15			sty charbuffer
   229 1517 A0 00			ldy #0
   230 1519			do_printinfo
   231 1519 BD FF FF		        lda $ffff,x
   232 = 151A			infosrc equ *-2
   233 151C 91 FE			sta (DISPLAY),y
   234 151E E8				inx
   235 151F C8				iny 
   236 1520 C0 00			cpy #0
   237 = 1521			charbuffer equ *-1
   238 1522 D0 F5			bne do_printinfo 
   239 1524 60				rts
   240
   241 				;-----------------
   242
   243 				; Print hex characters for several things, useful for displaying all sort of debugging infos
   244 					
   245 1525			printhex
   246 1525 A0 00			ldy #0
   247 1527			printhex_direct     ; workaround to allow being addressed with y in different subroutines
   248 1527 48				pha
   249 1528 4A 4A 4A 4A			:4 lsr @
   250 					;beq ph1    ; comment out if you want to hide the leftmost zeroes
   251 152C AA				tax
   252 152D BD 3D 15			lda hexchars,x
   253 1530			ph1	
   254 1530 91 FE C8		        sta (DISPLAY),y+
   255 1533 68				pla
   256 1534 29 0F			and #$f
   257 1536 AA				tax
   258 1537 BD 3D 15 91 FE		mva hexchars,x (DISPLAY),y
   259 153C 60				rts
   260 153D			hexchars 
   261 153D 10 11 12 13 14 15 +         dta d"0123456789ABCDEF"
   262
   263 				;-----------------
   264
   265 				;* Convert Hexadecimal numbers to Decimal without lookup tables 
   266 				;* Based on the routine created by Andrew Jacobs, 28-Feb-2004 
   267 				;* http://6502.org/source/integers/hex2dec-more.htm 
   268
   269 154D			hex2dec_convert
   270 154D C9 0A			cmp #10			; below 10 -> 0 to 9 inclusive will display like expected, skip the conversion
   271 154F 90 2E			bcc hex2dec_convert_b
   272 1551 C9 64			cmp #100		; process with numbers below 99, else skip the conversion entirely 
   273 1553 B0 2A			bcs hex2dec_convert_b  
   274 1555			hex2dec_convert_a
   275 1555 8D 82 15			sta hex_num		; temporary 
   276 1558 F8				sed
   277 1559 A9 00			lda #0			; initialise the conversion values
   278 155B 8D 80 15			sta dec_num
   279 155E 8D 81 15			sta dec_num+1
   280 1561 A2 07			ldx #7			; 8 bits to process 
   281 1563			hex2dec_loop
   282 1563 0E 82 15			asl hex_num 
   283 1566 AD 80 15			lda dec_num		; And add into result
   284 1569 6D 80 15			adc dec_num
   285 156C 8D 80 15			sta dec_num
   286 156F AD 81 15			lda dec_num+1		; propagating any carry
   287 1572 6D 81 15			adc dec_num+1
   288 1575 8D 81 15			sta dec_num+1
   289 1578 CA				dex			; And repeat for next bit
   290 1579 10 E8			bpl hex2dec_loop
   291 157B D8				cld			; Back to binary
   292 157C AD 80 15			lda dec_num 
   293 157F			hex2dec_convert_b
   294 157F 60				rts			; the value will be returned in the accumulator 
   295
   296 1580 00 00		dec_num dta $00,$00
   297 1582 00			hex_num dta $00
   298 					
   299 				;-----------------
   300
   301 				; Stop and quit when execution jumps here
   302
   303 1583			stop_and_exit
   304 1583 20 9B 12			jsr stop_pause_reset 
   305 1586 AD C4 1C 8D 22 02 + 	mwa oldvbi VVBLKI	; restore the old vbi address
   306 1592 A2 00			ldx #$00		; disable playfield 
   307 1594 8E 2F 02			stx SDMCTL		; write to Direct Memory Access (DMA) Control register
   308 1597 CA				dex			; underflow to #$FF
   309 1598 8E FC 02			stx CH			; write to the CH register, #$FF means no key pressed
   310 159B 58				cli			; this may be why it seems to crash on hardware... I forgot to clear the interrupt bit!
   311 159C 20 0D 15			jsr wait_vblank		; wait for vblank before continuing
   312 159F 6C 0A 00			jmp (DOSVEC)		; return to DOS, or Self Test by default
   313
   314 				;----------------- 
   315
   316 				;* Detect the machine region subroutine
   317
   318 15A2			detect_region	
   319 15A2 AD 0B D4			lda VCOUNT
   320 15A5 F0 03			beq check_region	; vcount = 0, go to check_region and compare values
   321 15A7 AA				tax			; backup the value in index y
   322 15A8 D0 F8			bne detect_region 	; repeat
   323 15AA			check_region
   324 				;	stx region_byte		; will define the region text to print later
   325 15AA A0 01			ldy #SongSpeed		; defined speed value, which may be overwritten by RMT as well
   326 = 15AB			PLAYER_SONG_SPEED equ *-1
   327 				;	sty instrspeed		; will be re-used later as well for the xVBI speed value printed
   328 					IFT REGIONPLAYBACK==0	; if the player region defined for PAL...
   329 = 15AC			PLAYER_REGION_INIT equ *	
   330 15AC B9 83 1C			lda tabppPAL-1,y
   331 15AF 8D 66 14			sta acpapx2		; lines between each play
   332 15B2 E0 9B			cpx #$9B		; compare X to 155
   333 15B4 30 07			bmi set_ntsc		; negative result means the machine runs at 60hz		
   334 15B6 B9 93 1C			lda tabppPALfix-1,y
   335 15B9 A0 32			ldy #50
   336 15BB D0 05			bne region_done 
   337 15BD			set_ntsc
   338 15BD B9 B3 1C			lda tabppNTSCfix-1,y	; if NTSC is detected, adjust the speed from PAL to NTSC
   339 15C0 A0 3C			ldy #60
   340 					ELI REGIONPLAYBACK==1	; else, if the player region defined for NTSC...
   341 				PLAYER_REGION_INIT equ *	
   342 					lda tabppNTSC-1,y
   343 					sta acpapx2		; lines between each play
   344 					cpx #$9B		; compare X to 155	
   345 					bpl set_pal		; positive result means the machine runs at 50hz 
   346 					lda tabppNTSCfix-1,y
   347 					ldy #60
   348 					bne region_done 
   349 				set_pal
   350 					lda tabppPALfix-1,y	; if PAL is detected, adjust the speed from NTSC to PAL
   351 					ldy #50
   352 					EIF			; endif 
   353 15C2			region_done
   354 15C2 8D 54 14			sta ppap		; stability fix for screen synchronisation 
   355 15C5 8C 52 13			sty framecount
   356 15C8 60				rts
   357
   358 				;-----------------
   359
   360 				;* Print most infos on screen
   361 					
   362 15C9			print_player_infos
   363 15C9 A9 44 85 FE A9 1B + 	mwa #line_0 DISPLAY 	; get the right screen position
   364 15D1			print_minutes
   365 15D1 AD 69 13			lda v_minute
   366 15D4 A0 08			ldy #8
   367 15D6 20 27 15			jsr printhex_direct
   368 15D9			print_seconds
   369 15D9 AE 5B 13			ldx v_second
   370 15DC 8A				txa
   371 15DD A0 0A			ldy #10
   372 15DF 29 01			and #1
   373 15E1 F0 04			beq no_blink 
   374 15E3 A9 00			lda #0
   375 15E5 F0 02			beq blink
   376 15E7			no_blink 
   377 15E7 A9 1A			lda #":" 
   378 15E9			blink
   379 15E9 91 FE			sta (DISPLAY),y 
   380 15EB C8				iny 
   381 15EC			done_blink
   382 15EC 8A				txa
   383 15ED 20 27 15			jsr printhex_direct
   384 15F0			print_order	
   385 15F0 A5 01			lda ZPLZS.SongPtr+1
   386 15F2 A0 22			ldy #34
   387 15F4 20 27 15			jsr printhex_direct
   388 15F7			print_row
   389 15F7 A5 00			lda ZPLZS.SongPtr 
   390 15F9 A0 24			ldy #36
   391 15FB 20 27 15			jsr printhex_direct 
   392 15FE			print_tune
   393 15FE A9 01			lda #1
   394 = 15FF			tune_index equ *-1
   395 1600 20 4D 15			jsr hex2dec_convert 
   396 1603 A0 7D			ldy #125
   397 1605 20 27 15			jsr printhex_direct 
   398 1608			print_sfx
   399 1608 A9 01			lda #1
   400 = 1609			sfx_index equ *-1
   401 160A 20 4D 15			jsr hex2dec_convert 
   402 160D A0 A5			ldy #165
   403 160F 20 27 15			jsr printhex_direct 
   404 1612			print_pointers
   405 1612 A0 37			ldy #55
   406 1614 AD 13 11			lda LZS.SongStartPtr+1
   407 1617 20 27 15			jsr printhex_direct
   408 161A C8				iny
   409 161B AD 12 11			lda LZS.SongStartPtr
   410 161E 20 27 15			jsr printhex_direct	
   411 1621 A0 47			ldy #71
   412 1623 AD 15 11			lda LZS.SongEndPtr+1
   413 1626 20 27 15			jsr printhex_direct
   414 1629 C8				iny
   415 162A AD 14 11			lda LZS.SongEndPtr
   416 162D 20 27 15			jsr printhex_direct
   417 1630			print_flags
   418 1630 A0 56			ldy #86
   419 1632 AD 1A 11			lda LZS.Initialized
   420 1635 20 27 15			jsr printhex_direct
   421 1638 A0 5E			ldy #94
   422 163A AD 27 13			lda is_playing_flag
   423 163D 20 27 15			jsr printhex_direct
   424 1640 A0 65			ldy #101
   425 1642 AD 07 12			lda is_looping 
   426 1645 38 E9 01			sub #1
   427 1648 20 27 15			jsr printhex_direct
   428 164B A0 6C			ldy #108
   429 164D AD 1D 12			lda loop_count 
   430 1650 20 27 15			jsr printhex_direct
   431 1653 A0 74			ldy #116
   432 1655 AD 42 12			lda is_fadeing_out
   433 1658 20 27 15			jsr printhex_direct
   434 165B 60				rts
   435 					
   436 				;-----------------
   437
   438 				;* Joystick input handler, using PORTA 
   439
   440 165C			check_joystick
   441 165C AE 00 D3			ldx PORTA
   442 165F 8A				txa
   443 1660 29 0F			and #%00001111
   444 1662 C9 0F			cmp #%00001111			; neutral
   445 1664 D0 1B			bne check_joystick_being_held
   446 1666 A9 00			lda #0
   447 1668 8D 82 16			sta held_joystick_flag		; reset held joystick flag
   448 166B AD 10 D0			lda TRIG0			; 'Fire' button
   449 166E F0 07			beq check_fire_being_held	; button pressed if 0
   450 1670 A9 00			lda #0
   451 1672 8D 78 16			sta held_fire_flag		; reset held button flag
   452 1675 F0 0E			beq check_joystick_done
   453 1677			check_fire_being_held
   454 1677 A9 00			lda #0
   455 = 1678			held_fire_flag equ *-1
   456 1679 30 0A			bmi check_joystick_done		; fire is already being held, ignore the input
   457 167B CE 78 16			dec held_fire_flag		; held button flag set again
   458 167E 4C F0 16			jmp set_sfx_to_play		; end with a RTS!
   459 1681			check_joystick_being_held
   460 1681 A9 00			lda #0
   461 = 1682			held_joystick_flag equ *-1
   462 1683 10 01			bpl check_joystick_up_down	; process the check, otherwise, a direction is already being held, ignore the input 	
   463 1685			check_joystick_done
   464 1685 60				rts
   465
   466 				;-----------------
   467
   468 				;* Up and Down bits
   469
   470 1686			check_joystick_up_down
   471 1686 AC 09 16			ldy sfx_index	
   472 1689 8A				txa
   473 168A 29 03			and #%00000011
   474 168C C9 03			cmp #%00000011
   475 168E F0 2A			beq check_joystick_left_right
   476 1690 CE 82 16			dec held_joystick_flag
   477
   478 				;-----------------
   479
   480 				;* Down
   481
   482 1693			do_joystick_down
   483 1693 C9 01			cmp #%00000001 
   484 1695 D0 0B			bne do_joystick_up
   485 1697 88				dey
   486 1698 F0 04			beq sfx_index_wrap
   487 169A 30 02			bmi sfx_index_wrap
   488 169C D0 11			bne update_sfx_index
   489 169E			sfx_index_wrap
   490 169E A0 0A			ldy #SFX_NUM
   491 16A0 10 0D			bpl update_sfx_index
   492
   493 				;-----------------
   494
   495 				;* Up
   496
   497 16A2			do_joystick_up	
   498 16A2 C9 02			cmp #%00000010 
   499 16A4 D0 09			bne update_sfx_index
   500 16A6 C8				iny
   501 16A7 C0 0A			cpy #SFX_NUM
   502 16A9 90 04			bcc update_sfx_index
   503 16AB F0 02			beq update_sfx_index
   504 16AD A0 01			ldy #1
   505 16AF			update_sfx_index
   506 16AF 8C 09 16			sty sfx_index 
   507 16B2 20 50 17			jsr check_sfx_index 
   508 16B5 A9 01			lda #1				; play sfx: menu movement 
   509 16B7 4C F2 16			jmp set_sfx_to_play_immediate	; end with a RTS! 
   510
   511 				;-----------------
   512
   513 				;* Left and Right bits
   514
   515 16BA			check_joystick_left_right
   516 16BA AC FF 15			ldy tune_index
   517 16BD 8A				txa
   518 16BE 29 0C			and #%00001100
   519 16C0 C9 0C			cmp #%00001100
   520 16C2 F0 C1			beq check_joystick_done
   521 16C4 CE 82 16			dec held_joystick_flag 
   522
   523 				;-----------------
   524
   525 				;* Left
   526
   527 16C7			do_joystick_left	
   528 16C7 C9 08			cmp #%00001000 
   529 16C9 D0 0C			bne do_joystick_right
   530 16CB 88				dey
   531 16CC F0 04			beq tune_index_wrap
   532 16CE 30 02			bmi tune_index_wrap
   533 16D0 D0 13			bne update_tune_index
   534 16D2			tune_index_wrap
   535 16D2 AC A5 17			ldy SongTotal
   536 16D5 10 0E			bpl update_tune_index
   537
   538 				;-----------------
   539
   540 				;* Right 
   541
   542 16D7			do_joystick_right	
   543 16D7 C9 04			cmp #%00000100 
   544 16D9 D0 0A			bne update_tune_index 
   545 16DB C8				iny
   546 16DC CC A5 17			cpy SongTotal
   547 16DF 90 04			bcc update_tune_index
   548 16E1 F0 02			beq update_tune_index
   549 16E3 A0 01			ldy #1
   550 16E5			update_tune_index
   551 16E5 8C FF 15			sty tune_index
   552 16E8 20 3A 17			jsr check_tune_index 
   553 16EB A9 01			lda #1				; play sfx: menu movement 
   554 16ED 4C F2 16			jmp set_sfx_to_play_immediate	; end with a RTS!  
   555
   556 				;-----------------
   557
   558 				;* Initialise the SFX to play in memory once the joystick button is pressed, using the SFX index number
   559
   560 16F0			set_sfx_to_play
   561 16F0 A9 00			lda #0
   562 = 16F1			SfxIdx equ *-1
   563 16F2			set_sfx_to_play_immediate
   564 16F2 0A				asl @
   565 16F3 AA				tax
   566 16F4 BD CC 19			lda sfx_data,x
   567 16F7 8D 27 17			sta sfx_src
   568 16FA BD CD 19			lda sfx_data+1,x
   569 16FD 8D 28 17			sta sfx_src+1
   570 1700 EE 0F 17			inc is_playing_sfx 
   571 1703 A9 03			lda #3 
   572 1705 8D 1F 17			sta sfx_channel
   573 1708 A9 00			lda #0
   574 170A 8D 18 17			sta sfx_offset
   575 170D 60				rts
   576
   577 				;-----------------
   578
   579 				;* Play the SFX currently set in memory, one frame every VBI
   580
   581 170E			play_sfx
   582 170E A9 FF			lda #$FF		; #$00 -> Play SFX until it's ended, #$FF -> SFX has finished playing and is stopped
   583 = 170F			is_playing_sfx equ *-1
   584 1710 30 27			bmi play_sfx_done
   585 1712 A9 02			lda #2			; 2 frames
   586 1714 8D 0F 17			sta is_playing_sfx
   587 1717 A9 00			lda #0
   588 = 1718			sfx_offset equ *-1
   589 1719 0A				asl @
   590 171A AA				tax
   591 171B EE 18 17			inc sfx_offset
   592 171E A9 00			lda #0
   593 = 171F			sfx_channel equ *-1
   594 1720 0A				asl @
   595 1721 A8				tay
   596 1722 10 02			bpl begin_play_sfx
   597 1724			play_sfx_loop
   598 1724 E8				inx
   599 1725 C8				iny
   600 1726			begin_play_sfx
   601 1726 BD FF FF		        lda $ffff,x
   602 = 1727			sfx_src equ *-2
   603 1729 99 CD 13			sta SDWPOK0,y
   604 172C CE 0F 17			dec is_playing_sfx
   605 172F D0 F3			bne play_sfx_loop
   606 1731 B9 CD 13			lda SDWPOK0,y
   607 1734 D0 03			bne play_sfx_done
   608 1736 CE 0F 17			dec is_playing_sfx
   609 1739			play_sfx_done
   610 1739 60				rts
   611
   612 				;-----------------
   613
   614 				;* Compare the tune index number to the one being displayed
   615 				;* If they don't match, a new tune will play!
   616
   617 173A			check_tune_index 
   618 173A AE FF 15			ldx tune_index
   619 173D CA				dex				; offset by 1, since the first entry is 0
   620 173E EC E7 11			cpx SongIdx
   621 1741 D0 01			bne check_tune_index_a 
   622 1743			check_tune_index_done	
   623 1743 60				rts				; if they are the same, there is nothing else to do here 
   624 1744			check_tune_index_a	
   625 1744 8E E7 11			stx SongIdx
   626 1747 20 62 17			jsr update_tune_name 
   627 174A 20 DB 11			jsr SetNewSongPtrsFull 
   628 174D 4C 74 13			jmp reset_timer 		; end with a RTS! 
   629
   630 				;-----------------
   631
   632 				;* Compare the sfx index number to the one being displayed
   633 				;* If they don't match, a new sfx will play!
   634
   635 1750			check_sfx_index 
   636 1750 AE 09 16			ldx sfx_index
   637 1753 CA				dex				; offset by 1, since the first entry is 0
   638 1754 EC F1 16			cpx SfxIdx 
   639 1757 D0 01			bne check_sfx_index_a 
   640 1759			check_sfx_index_done	
   641 1759 60				rts				; if they are the same, there is nothing else to do here 
   642 175A			check_sfx_index_a
   643 175A 8E F1 16			stx SfxIdx
   644 175D 4C 79 17			jmp update_sfx_name 		; end with a RTS! 
   645
   646 				;-----------------
   647
   648 				;* Update the song name displayed on screen based on the index number
   649
   650 1760			set_tune_name
   651 1760 A2 00			ldx #0				; default index number, else, use the value from X directly
   652 1762			update_tune_name
   653 1762 A9 C8 85 FE A9 1B + 	mwa #line_3+12 DISPLAY		; set the screen coordinates for the song name displayed on screen
   654 176A A9 4C 8D 1A 15 A9 + 	mwa #song_name infosrc		; set the memory address for the text data 
   655 1774 4C 8B 17			jmp update_both_name		; end with a RTS over there! 
   656
   657 				;-----------------
   658
   659 				;* Update the sfx name displayed on screen based on the index number
   660
   661 1777			set_sfx_name
   662 1777 A2 00			ldx #0				; default index number, else, use the value from X directly
   663 1779			update_sfx_name
   664 1779 A9 F0 85 FE A9 1B + 	mwa #line_4+12 DISPLAY		; set the screen coordinates for the sfx name displayed on screen
   665 1781 A9 8C 8D 1A 15 A9 + 	mwa #sfx_name infosrc		; set the memory address for the text data 
   666
   667 				;-----------------
   668
   669 				;* Both the song name and sfx name will use the same code for drawing text on screen after addresses initialisation 
   670
   671 178B			update_both_name 
   672 178B 8A				txa
   673 178C 0A 0A 0A 0A 0A		:5 asl @
   674 1791 90 03 EE 1B 15		scc:inc infosrc+1
   675 1796 AA				tax 
   676 1797 A0 1C			ldy #28				; 32 characters per index 
   677 1799 4C 14 15			jmp printinfo			; end with a RTS! 
   678
   679 				;-----------------
   680
   681 				;* Display the number of tunes and sfx indexed in memory, using the values defined at assembly time 
   682
   683 179C			set_index_count
   684 179C A9 44 85 FE A9 1B + 	mwa #line_0 DISPLAY 		; get the right screen position
   685 17A4 A9 02			lda #TUNE_NUM
   686 = 17A5				SongTotal equ *-1
   687 17A6 20 4D 15			jsr hex2dec_convert 
   688 17A9 A0 80			ldy #128 
   689 17AB 20 27 15			jsr printhex_direct
   690 17AE A9 0A			lda #SFX_NUM
   691 17B0 20 4D 15			jsr hex2dec_convert 
   692 17B3 A0 A8			ldy #168
   693 17B5 20 27 15			jsr printhex_direct
   694 17B8 60				rts
   695
   696 				;-----------------
   697
   698 				;* check all keys that have a purpose here... 
   699 				;* this is the world's most cursed jumptable ever created!
   700 				;* regardless, this finally gets rid of all the spaghetti code I made previously!
   701
   702 17B9			check_keys 
   703 17B9 98				tya				; transfer to the accumulator to make a quick and dirty jump table
   704 17BA 0A				asl @				; ASL only once, allowing a 2 bytes index, good enough for branching again immediately and unconditionally, 128 bytes needed sadly...
   705 17BB 8D BF 17			sta k_index+1			; branch will now match the value of Y
   706 17BE D0 FE		k_index	bne * 
   707 17C0 60 EA			rts:nop				; Y = 0 -> L key
   708 17C2 60 EA			rts:nop
   709 17C4 60 EA			rts:nop
   710 17C6 60 EA			rts:nop
   711 17C8 60 EA			rts:nop
   712 17CA 60 EA			rts:nop
   713 17CC 60 EA			rts:nop				; Y = 6 -> Atari 'Left' / '+' key
   714 17CE 60 EA			rts:nop				; Y = 7 -> Atari 'Right' / '*' key 
   715 17D0 90 71			bcc do_stop_toggle 		; Y = 8 -> 'O' key (not zero!!) 
   716 17D2 60 EA			rts:nop
   717 17D4 90 70			bcc do_play_pause_toggle	; Y = 10 -> 'P' key
   718 17D6 60 EA			rts:nop
   719 17D8 60 EA			rts:nop				; Y = 12 -> 'Enter' key
   720 17DA 60 EA			rts:nop
   721 17DC 60 EA			rts:nop
   722 17DE 60 EA			rts:nop
   723 17E0 60 EA			rts:nop
   724 17E2 60 EA			rts:nop
   725 17E4 60 EA			rts:nop				; Y = 18 -> 'C' key
   726 17E6 60 EA			rts:nop
   727 17E8 60 EA			rts:nop
   728 17EA 60 EA			rts:nop
   729 17EC 60 EA			rts:nop				; Y = 22 -> 'X' key
   730 17EE 60 EA			rts:nop				; Y = 23 -> 'Z' key
   731 17F0 60 EA			rts:nop				; Y = 24 -> '4' key
   732 17F2 60 EA			rts:nop
   733 17F4 60 EA			rts:nop				; Y = 26 -> '3' key
   734 17F6 60 EA			rts:nop				; Y = 27 -> '6' key
   735 17F8 90 46			bcc do_exit			; Y = 28 -> 'Escape' key
   736 17FA 60 EA			rts:nop				; Y = 29 -> '5' key
   737 17FC 60 EA			rts:nop				; Y = 30 -> '2' key
   738 17FE 60 EA			rts:nop				; Y = 31 -> '1' key
   739 1800 60 EA			rts:nop
   740 1802 60 EA			rts:nop			 	; Y = 33 -> 'Spacebar' key
   741 1804 60 EA			rts:nop
   742 1806 60 EA			rts:nop
   743 1808 60 EA			rts:nop
   744 180A 60 EA			rts:nop
   745 180C 60 EA			rts:nop
   746 180E 60 EA			rts:nop
   747 1810 60 EA			rts:nop				; Y = 40 -> 'R' key
   748 1812 60 EA			rts:nop
   749 1814 60 EA			rts:nop
   750 1816 60 EA			rts:nop
   751 1818 60 EA			rts:nop
   752 181A 60 EA			rts:nop
   753 181C 60 EA			rts:nop				; Y = 46 -> 'W' key
   754 181E 60 EA			rts:nop
   755 1820 60 EA			rts:nop
   756 1822 60 EA			rts:nop
   757 1824 60 EA			rts:nop
   758 1826 60 EA			rts:nop				; Y = 51 -> '7' key
   759 1828 60 EA			rts:nop
   760 182A 60 EA			rts:nop				; Y = 53 -> '8' key
   761 182C 60 EA			rts:nop
   762 182E 60 EA			rts:nop
   763 1830 90 17			bcc do_trigger_fade_immediate	; Y = 56 -> 'F' key
   764 1832 60 EA			rts:nop				; Y = 57 -> 'H' key
   765 1834 60 EA			rts:nop				; Y = 58 -> 'D' key
   766 1836 60 EA			rts:nop
   767 1838 60 EA			rts:nop
   768 183A 60 EA			rts:nop
   769 183C 60 EA			rts:nop				; Y = 62 -> 'S' key
   770 183E 60 EA			rts:nop				; Y = 63 -> 'A' key
   771
   772 				;-----------------
   773
   774 				;* Jumptable from the branches above, long range in case things don't quite reach 
   775
   776 1840			do_exit
   777 1840 4C 83 15			jmp stop_and_exit		; stop and exit to DOS 
   778 					
   779 1843			do_stop_toggle
   780 1843 4C 8A 12			jmp stop_toggle			; toggle stop flag
   781 					
   782 1846			do_play_pause_toggle	
   783 1846 4C 26 13			jmp play_pause_toggle		; toggle play/pause flag
   784
   785 1849			do_trigger_fade_immediate
   786 1849 4C 39 13			jmp trigger_fade_immediate	; immediately set the 'fadeout' flag then stop the player once finished
   787 					
   788 				;-----------------
   789
   790 				;//---------------------------------------------------------------------------------------------
   791
   792 				;* Song and SFX text data, 32 characters per entry, display 28 characters or less for best results
   793
   794 184C			song_name 
   795 184C 26 6C 6F 62 00 0D + 	dta d"Flob - Escape from the Lab      "
   796 186C 27 6F 72 64 69 61 + 	dta d"Gordian Tomb - Tune 1 Stereo    "
   797 				/*
   798 					dta d"Sketch 53                       "
   799 					dta d"Sieur Goupil                    "
   800 					dta d"Shoreline From Another World    "
   801 					dta d"Sketch 58                       "
   802 					dta d"Sketch 69                       "
   803 					dta d"Sketch 24                       "
   804 					dta d"Another Dumb Experiment         "
   805 					dta d"Bouncy Bouncer                  "
   806 				*/
   806
   807
   808 188C			sfx_name
   809 188C 2D 65 6E 75 00 0D + 	dta d"Menu - Press                    " 
   810 18AC 2D 65 6E 75 00 0D + 	dta d"Menu - Movement                 " 
   811 18CC 2D 65 6E 75 00 0D + 	dta d"Menu - Keyclick                 " 
   812 18EC 2D 65 6E 75 00 0D + 	dta d"Menu - Code Rejected            " 
   813 190C 2D 65 6E 75 00 0D + 	dta d"Menu - Code Accepted            " 
   814 192C 27 61 6D 65 00 0D + 	dta d"Game - Select Unselect          " 
   815 194C 27 61 6D 65 00 0D + 	dta d"Game - Move Fox                 " 
   816 196C 27 61 6D 65 00 0D + 	dta d"Game - Move Bunny               " 
   817 198C 27 61 6D 65 00 0D + 	dta d"Game - In Hole                  " 
   818 19AC 27 61 6D 65 00 0D + 	dta d"Game - Cannot Do                " 
   819
   820 				;-----------------
   821
   822 				;* Sound effects index  
   823
   824 19CC			sfx_data
   825 19CC E0 19			dta a(sfx_00)
   826 19CE 0A 1A			dta a(sfx_01)
   827 19D0 24 1A			dta a(sfx_02)
   828 19D2 38 1A			dta a(sfx_03)
   829 19D4 52 1A			dta a(sfx_04)
   830 19D6 8E 1A			dta a(sfx_05)
   831 19D8 A0 1A			dta a(sfx_06)
   832 19DA C2 1A			dta a(sfx_07)
   833 19DC EA 1A			dta a(sfx_08)
   834 19DE 30 1B			dta a(sfx_09)  
   835
   836 				;* Sound effects data 
   837
   838 19E0 5F A8 5F A6 5F A5 + sfx_00	ins '/Bunny Hop SFX/menu-press.sfx'
   839 1A0A 5F A8 5F A6 2F A8 + sfx_01	ins '/Bunny Hop SFX/menu-movement.sfx'
   840 1A24 1D A7 3B A5 3B A3 + sfx_02	ins '/Bunny Hop SFX/menu-keyclick.sfx'
   841 1A38 1F C9 1F C9 EC A8 + sfx_03	ins '/Bunny Hop SFX/menu-code_rejected.sfx'
   842 1A52 28 A9 28 A9 28 A8 + sfx_04	ins '/Bunny Hop SFX/menu-code_accepted.sfx'
   843 1A8E 1D A7 50 A8 50 A5 + sfx_05	ins '/Bunny Hop SFX/game-select_unselect.sfx'
   844 1AA0 07 01 05 02 04 03 + sfx_06	ins '/Bunny Hop SFX/game-move_fox.sfx'
   845 1AC2 71 A7 38 A7 6B A7 + sfx_07	ins '/Bunny Hop SFX/game-move_bunny.sfx'
   846 1AEA 3C A6 78 A8 78 A7 + sfx_08	ins '/Bunny Hop SFX/game-in_hole.sfx'
   847 1B30 4C C8 4C C8 4C C8 + sfx_09	ins '/Bunny Hop SFX/game-cannot_do.sfx' 
   848
   849 				;-----------------
   850
   851 				;* Screen memory 
   852 					
   853 1B44 00 00 34 69 6D 65 + line_0	dta d"  Time: 00:00      LZSS Address: $0000  "
   854 1B6C 00 00 00 00 33 74 + line_1	dta d"    StartPtr: $0000   EndPtr: $0000     "
   855 1B94 00 00 29 1A 00 04 + line_2	dta d"  I: $00  P: $00 C: $00 L: $00  F: $00  "
   856 1BBC 34 75 6E 65 00 10 + line_3	dta d"Tune 01/01: (insert title here)         "
   857 1BE4 00 33 26 38 00 10 + line_4	dta d" SFX 01/01: (28 chars or less maybe)    "
   858 1C0C 00 00 00 00 00 34 + line_5	dta d"     Tune: Left/Right SFX: Up/Down      "
   859 1C34 00 00 30 72 65 73 + line_6	dta d"  Press 'Fire' to play the selected SFX "
   860 1C5C 00 24 35 2D 22 00 + line_7	dta d" DUMB Soundtest-LZSS by VinsCool   "
   861 1C7F F6 90 8E 91 00	line_7a	dta d"v0.1"*,$00
   862
   863 				;-----------------
   864
   865 				;* line counter spacing table for instrument speed from 1 to 16
   866
   867 				;-----------------
   868
   869 				;* the idea here is to pick the best sweet spots each VBI multiples to form 1 "optimal" table, for each region
   870 				;* it seems like the number of lines for the 'fix' value MUST be higher than either 156 for better stability
   871 				;* else, it will 'roll' at random, which is not good! better sacrifice a few lines to keep it stable...
   872 				;* strangely enough, NTSC does NOT suffer from this weird rolling effect... So that one can use values above or below 131 fine
   873
   874 				;	    x1  x2  x3  x4  x5  x6  x7  x8  x9  x10 x11 x12 x13 x14 x15 x16 
   875
   876 1C84			tabppPAL	; "optimal" PAL timing table
   877 1C84 9C 4E 34 27 20 1A + 	dta $9C,$4E,$34,$27,$20,$1A,$17,$14,$12,$10,$0F,$0D,$0C,$0C,$0B,$0A
   878 					
   879 1C94			tabppPALfix	; interval offsets for timing stability 
   880 1C94 9C 9C 9C 9C A0 9C + 	dta $9C,$9C,$9C,$9C,$A0,$9C,$A1,$A0,$A2,$A0,$A5,$9C,$9C,$A8,$A5,$A0
   881 					
   882 				;-----------------
   883 					
   884 				;* NTSC needs its own adjustment table too... And so will cross-region from both side... Yay numbers! 
   885 				;* adjustments between regions get a lot trickier however...
   886 				;* for example: 
   887 				;* 1xVBI NTSC to PAL, 130 on 156 does work for a stable rate, but it would get all over the place for another number 
   888
   889 				;	    x1  x2  x3  x4  x5  x6  x7  x8  x9  x10 x11 x12 x13 x14 x15 x16 
   890 					
   891 1CA4			tabppNTSC	; "optimal" NTSC timing table
   892 1CA4 82 41 2B 20 1A 15 + 	dta $82,$41,$2B,$20,$1A,$15,$12,$10,$0E,$0D,$0B,$0A,$0A,$09,$08,$08
   893
   894 1CB4			tabppNTSCfix	; interval offsets for timing stability 
   895 1CB4 82 82 81 80 82 7E + 	dta $82,$82,$81,$80,$82,$7E,$7E,$80,$7E,$82,$79,$78,$82,$7E,$78,$80
   896
   897 				;-----------------
   898
   899 				;* TODO: add cross region tables fix, might be a pain in the ass, blegh...
   900
   901 				;-----------------
   902
   903 				;* VBI address backup 
   904
   905 1CC4			oldvbi	
   906 1CC4 00 00			dta a(0) 
   907 					
   908 				;-----------------
   909
   910 				;* Display list 
   911
   912 1CC6			dlist 
   913 1CC6 70 70 70 70 70 70		:6 dta $70		; start with 6 empty lines
   914 1CCC 42				dta $42			; ANTIC mode 2 
   915 1CCD 44 1B			dta a(line_0)		; line_0 
   916 1CCF 70				:1 dta $70		; empty lines
   917 1CD0 02				dta $02			; line_1
   918 1CD1 70				:1 dta $70		; empty lines
   919 1CD2 02				dta $02			; line_2
   920 1CD3 70 70 70			:3 dta $70		; empty lines
   921 1CD6 02 02			:2 dta $02		; line_3 and line_4
   922 1CD8 70 70			:2 dta $70		; empty lines
   923 1CDA 02				dta $02			; line_5
   924 1CDB 70				:1 dta $70		; empty lines
   925 1CDC 02				dta $02			; line_6 
   926 1CDD 70 70 70 70			:4 dta $70		; empty lines
   927 1CE1 02				dta $02			; line_7 
   928 1CE2 41 C6 1C			dta $41,a(dlist)	; Jump and wait for vblank, return to dlist 
   929 02E0-02E1> E1 13			run start 		; run address was put here for simplicity, so it come after everything else in memory 
   930
   931 				;----------------- 
   932
   933 				;//---------------------------------------------------------------------------------------------
   934
   935 				;* And that's all folks :D
   936
   937 				;----------------- 
   938
   434
   435 				;-----------------
   436
   437 				;//---------------------------------------------------------------------------------------------
   438
   439 				;* Songs index and data will be inserted here, after everything else, that way they are easy to modify externally
   440
   441 				;	org SONGINDEX	
   442 1CE5				icl "SongIndex.asm" 
Source: SongIndex.asm
     1 				;* Songs index always begin with the "intro" section, followed by the "loop" section, when applicable 
     2 				;* Index list must end with the dummy tune address to mark the end of each list properly 
     3 				;* Make sure to define the total number of tunes that could be indexed in code using it to avoid garbage data being loaded 
     4
     5 1CE5			SongIndex 
     6 1CE5-4E9E> FA 1C ED 1C		dta a(SNG_0),a(SEQ_0) 
     7 1CE9 0E 1D F8 1C			dta a(SNG_1),a(SEQ_1) 
     8 				/*
     9 					dta a(SNG_0),a(SEQ_0) 
    10 					dta a(SNG_1),a(SEQ_0) 
    11 					dta a(SNG_2),a(SEQ_0) 
    12 					dta a(SNG_3),a(SEQ_1) 
    13 					dta a(SNG_4),a(SEQ_1) 
    14 					dta a(SNG_5),a(SEQ_1) 
    15 					dta a(SNG_6),a(SEQ_1) 
    16 					dta a(SNG_7),a(SEQ_0) 
    17 				*/
    17
    18 1CED			SongIndexEnd 
    19
    20 				;-----------------
    21 						
    22 				;//---------------------------------------------------------------------------------------------
    23
    24 1CED			SongSequence
    25 				;SEQ_0	dta $00,$01,$81
    26 1CED 00 01 02 03 04 05 + SEQ_0	dta $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$82
    27 1CF8 00 80		SEQ_1	dta $00,$80
    28 1CFA			SongSequenceEnd 
    29
    30 				;-----------------
    31 						
    32 				;//---------------------------------------------------------------------------------------------
    33
    34 1CFA			SongSection
    35 1CFA 12 1D		SNG_0	dta a(LZ00)
    36 1CFC ED 1D			dta a(LZ01)
    37 1CFE 97 1F			dta a(LZ02)
    38 1D00 BF 21			dta a(LZ03)
    39 1D02 3B 24			dta a(LZ04)
    40 1D04 D3 26			dta a(LZ05)
    41 1D06 4C 29			dta a(LZ06)
    42 1D08 D8 2B			dta a(LZ07)
    43 1D0A 08 2E			dta a(LZ08)
    44 1D0C 67 30			dta a(LZ09)
    45 1D0E BC 31		SNG_1	dta a(LZ10)
    46 				/*
    47 					dta a(LZ01)
    48 				SNG_1	dta a(LZ10)
    49 					dta a(LZ11)
    50 				SNG_2	dta a(LZ20)
    51 					dta a(LZ21)
    52 				SNG_3	dta a(LZ30)
    53 				SNG_4	dta a(LZ40)
    54 				SNG_5	dta a(LZ50)
    55 				SNG_6	dta a(LZ60)
    56 				SNG_7	dta a(LZ70)
    57 					dta a(LZ71)
    58 				*/
    58
    59 1D10 9F 4E		SNG_END	dta a(LZ_END) 
    60 1D12			SongSectionEnd 
    61
    62 				;-----------------
    63 						
    64 				;//---------------------------------------------------------------------------------------------
    65
    66 				;* LZSS data, all in a single block
    67
    68 1D12			LZ_DTA
    69 1D12 87 00 00 00 A7 3F + LZ00	ins '/RANDOM3/lab.lz00'
    70 1DED 81 00 00 00 A7 3F + LZ01	ins '/RANDOM3/lab.lz01'
    71 1F97 81 00 82 00 A6 5F + LZ02	ins '/RANDOM3/lab.lz02'
    72 21BF 81 00 82 00 A6 5F + LZ03	ins '/RANDOM3/lab.lz03'
    73 243B 81 00 82 00 A6 5F + LZ04	ins '/RANDOM3/lab.lz04'
    74 26D3 81 00 82 00 A6 54 + LZ05	ins '/RANDOM3/lab.lz05'
    75 294C 81 00 82 00 A6 54 + LZ06	ins '/RANDOM3/lab.lz06'
    76 2BD8 81 00 82 00 A6 54 + LZ07	ins '/RANDOM3/lab.lz07'
    77 2E08 81 00 82 00 A6 54 + LZ08	ins '/RANDOM3/lab.lz08'
    78 3067 81 00 C5 AA A7 3F + LZ09	ins '/RANDOM3/lab.lz09'
    79 31BC 00 00 00 6B 00 00 + LZ10	ins '/RANDOM3/Gordian Tomb Stereo.lzss'
    80 				/*
    81 				LZ00	ins '/RANDOM3/SKETCH_53.lzss'
    82 				LZ01	ins '/RANDOM3/SKETCH_53_LOOP.lzss'
    83 				LZ10	ins '/RANDOM3/SIEUR_GOUPIL.lzss'
    84 				LZ11	ins '/RANDOM3/SIEUR_GOUPIL_LOOP.lzss'
    85 				LZ20	ins '/RANDOM3/SHORELINE.lzss'
    86 				LZ21	ins '/RANDOM3/SHORELINE_LOOP.lzss'
    87 				LZ30	ins '/RANDOM3/SKETCH_58_LOOP.lzss'
    88 				LZ40	ins '/RANDOM3/SKETCH_69_LOOP.lzss'
    89 				LZ50	ins '/RANDOM3/SKETCH_24_LOOP.lzss'
    90 				LZ60	ins '/RANDOM3/DUMB3_LOOP.lzss'
    91 				LZ70	ins '/RANDOM3/BOUNCY_BOUNCER.lzss'
    92 				LZ71	ins '/RANDOM3/BOUNCY_BOUNCER_LOOP.lzss'
    93 				*/
    93
    94 4E9F			LZ_END
    95
    96 				;-----------------
    97 						
    98 				;//---------------------------------------------------------------------------------------------
    99
   443 					
   444 				;-----------------
   445
   446 				;//---------------------------------------------------------------------------------------------
   447
